<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>removeformatting.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="closure_goog_editor_plugins_removeformatting.js.html">removeformatting.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2008 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>// All Rights Reserved.
<a name="line15"></a>
<a name="line16"></a>/**
<a name="line17"></a> * @fileoverview Plugin to handle Remove Formatting.
<a name="line18"></a> *
<a name="line19"></a> */
<a name="line20"></a>
<a name="line21"></a>goog.provide(&#39;goog.editor.plugins.RemoveFormatting&#39;);
<a name="line22"></a>
<a name="line23"></a>goog.require(&#39;goog.dom&#39;);
<a name="line24"></a>goog.require(&#39;goog.dom.NodeType&#39;);
<a name="line25"></a>goog.require(&#39;goog.dom.Range&#39;);
<a name="line26"></a>goog.require(&#39;goog.dom.TagName&#39;);
<a name="line27"></a>goog.require(&#39;goog.editor.BrowserFeature&#39;);
<a name="line28"></a>goog.require(&#39;goog.editor.Plugin&#39;);
<a name="line29"></a>goog.require(&#39;goog.editor.node&#39;);
<a name="line30"></a>goog.require(&#39;goog.editor.range&#39;);
<a name="line31"></a>goog.require(&#39;goog.string&#39;);
<a name="line32"></a>
<a name="line33"></a>
<a name="line34"></a>
<a name="line35"></a>/**
<a name="line36"></a> * A plugin to handle removing formatting from selected text.
<a name="line37"></a> * @constructor
<a name="line38"></a> * @extends {goog.editor.Plugin}
<a name="line39"></a> */
<a name="line40"></a>goog.editor.plugins.RemoveFormatting = function() {
<a name="line41"></a>  goog.editor.Plugin.call(this);
<a name="line42"></a>
<a name="line43"></a>  /**
<a name="line44"></a>   * Optional function to perform remove formatting in place of the
<a name="line45"></a>   * provided removeFormattingWorker_.
<a name="line46"></a>   * @type {?function(string): string}
<a name="line47"></a>   * @private
<a name="line48"></a>   */
<a name="line49"></a>  this.optRemoveFormattingFunc_ = null;
<a name="line50"></a>};
<a name="line51"></a>goog.inherits(goog.editor.plugins.RemoveFormatting, goog.editor.Plugin);
<a name="line52"></a>
<a name="line53"></a>
<a name="line54"></a>/**
<a name="line55"></a> * The editor command this plugin in handling.
<a name="line56"></a> * @type {string}
<a name="line57"></a> */
<a name="line58"></a>goog.editor.plugins.RemoveFormatting.REMOVE_FORMATTING_COMMAND =
<a name="line59"></a>    &#39;+removeFormat&#39;;
<a name="line60"></a>
<a name="line61"></a>
<a name="line62"></a>/**
<a name="line63"></a> * Regular expression that matches a block tag name.
<a name="line64"></a> * @type {RegExp}
<a name="line65"></a> * @private
<a name="line66"></a> */
<a name="line67"></a>goog.editor.plugins.RemoveFormatting.BLOCK_RE_ =
<a name="line68"></a>    /^(DIV|TR|LI|BLOCKQUOTE|H\d|PRE|XMP)/;
<a name="line69"></a>
<a name="line70"></a>
<a name="line71"></a>/**
<a name="line72"></a> * Appends a new line to a string buffer.
<a name="line73"></a> * @param {Array.&lt;string&gt;} sb The string buffer to add to.
<a name="line74"></a> * @private
<a name="line75"></a> */
<a name="line76"></a>goog.editor.plugins.RemoveFormatting.appendNewline_ = function(sb) {
<a name="line77"></a>  sb.push(&#39;&lt;br&gt;&#39;);
<a name="line78"></a>};
<a name="line79"></a>
<a name="line80"></a>
<a name="line81"></a>/**
<a name="line82"></a> * Create a new range delimited by the start point of the first range and
<a name="line83"></a> * the end point of the second range.
<a name="line84"></a> * @param {goog.dom.AbstractRange} startRange Use the start point of this
<a name="line85"></a> *    range as the beginning of the new range.
<a name="line86"></a> * @param {goog.dom.AbstractRange} endRange Use the end point of this
<a name="line87"></a> *    range as the end of the new range.
<a name="line88"></a> * @return {goog.dom.AbstractRange} The new range.
<a name="line89"></a> * @private
<a name="line90"></a> */
<a name="line91"></a>goog.editor.plugins.RemoveFormatting.createRangeDelimitedByRanges_ = function(
<a name="line92"></a>    startRange, endRange) {
<a name="line93"></a>  return goog.dom.Range.createFromNodes(
<a name="line94"></a>      startRange.getStartNode(), startRange.getStartOffset(),
<a name="line95"></a>      endRange.getEndNode(), endRange.getEndOffset());
<a name="line96"></a>};
<a name="line97"></a>
<a name="line98"></a>
<a name="line99"></a>/** @override */
<a name="line100"></a>goog.editor.plugins.RemoveFormatting.prototype.getTrogClassId = function() {
<a name="line101"></a>  return &#39;RemoveFormatting&#39;;
<a name="line102"></a>};
<a name="line103"></a>
<a name="line104"></a>
<a name="line105"></a>/** @override */
<a name="line106"></a>goog.editor.plugins.RemoveFormatting.prototype.isSupportedCommand = function(
<a name="line107"></a>    command) {
<a name="line108"></a>  return command ==
<a name="line109"></a>      goog.editor.plugins.RemoveFormatting.REMOVE_FORMATTING_COMMAND;
<a name="line110"></a>};
<a name="line111"></a>
<a name="line112"></a>
<a name="line113"></a>/** @override */
<a name="line114"></a>goog.editor.plugins.RemoveFormatting.prototype.execCommandInternal =
<a name="line115"></a>    function(command, var_args) {
<a name="line116"></a>  if (command ==
<a name="line117"></a>      goog.editor.plugins.RemoveFormatting.REMOVE_FORMATTING_COMMAND) {
<a name="line118"></a>    this.removeFormatting_();
<a name="line119"></a>  }
<a name="line120"></a>};
<a name="line121"></a>
<a name="line122"></a>
<a name="line123"></a>/** @override */
<a name="line124"></a>goog.editor.plugins.RemoveFormatting.prototype.handleKeyboardShortcut =
<a name="line125"></a>    function(e, key, isModifierPressed) {
<a name="line126"></a>  if (!isModifierPressed) {
<a name="line127"></a>    return false;
<a name="line128"></a>  }
<a name="line129"></a>
<a name="line130"></a>  if (key == &#39; &#39;) {
<a name="line131"></a>    this.fieldObject.execCommand(
<a name="line132"></a>        goog.editor.plugins.RemoveFormatting.REMOVE_FORMATTING_COMMAND);
<a name="line133"></a>    return true;
<a name="line134"></a>  }
<a name="line135"></a>
<a name="line136"></a>  return false;
<a name="line137"></a>};
<a name="line138"></a>
<a name="line139"></a>
<a name="line140"></a>/**
<a name="line141"></a> * Removes formatting from the current selection.  Removes basic formatting
<a name="line142"></a> * (B/I/U) using the browser&#39;s execCommand.  Then extracts the html from the
<a name="line143"></a> * selection to convert, calls either a client&#39;s specified removeFormattingFunc
<a name="line144"></a> * callback or trogedit&#39;s general built-in removeFormattingWorker_,
<a name="line145"></a> * and then replaces the current selection with the converted text.
<a name="line146"></a> * @private
<a name="line147"></a> */
<a name="line148"></a>goog.editor.plugins.RemoveFormatting.prototype.removeFormatting_ = function() {
<a name="line149"></a>  var range = this.fieldObject.getRange();
<a name="line150"></a>  if (range.isCollapsed()) {
<a name="line151"></a>    return;
<a name="line152"></a>  }
<a name="line153"></a>
<a name="line154"></a>  // Get the html to format and send it off for formatting. Built in
<a name="line155"></a>  // removeFormat only strips some inline elements and some inline CSS styles
<a name="line156"></a>  var convFunc = this.optRemoveFormattingFunc_ ||
<a name="line157"></a>                 goog.bind(this.removeFormattingWorker_, this);
<a name="line158"></a>  this.convertSelectedHtmlText_(convFunc);
<a name="line159"></a>
<a name="line160"></a>  // Do the execCommand last as it needs block elements removed to work
<a name="line161"></a>  // properly on background/fontColor in FF. There are, unfortunately, still
<a name="line162"></a>  // cases where background/fontColor are not removed here.
<a name="line163"></a>  var doc = this.getFieldDomHelper().getDocument();
<a name="line164"></a>  doc.execCommand(&#39;RemoveFormat&#39;, false, undefined);
<a name="line165"></a>
<a name="line166"></a>  if (goog.editor.BrowserFeature.ADDS_NBSPS_IN_REMOVE_FORMAT) {
<a name="line167"></a>    // WebKit converts spaces to non-breaking spaces when doing a RemoveFormat.
<a name="line168"></a>    // See: https://bugs.webkit.org/show_bug.cgi?id=14062
<a name="line169"></a>    this.convertSelectedHtmlText_(function(text) {
<a name="line170"></a>      // This loses anything that might have legitimately been a non-breaking
<a name="line171"></a>      // space, but that&#39;s better than the alternative of only having non-
<a name="line172"></a>      // breaking spaces.
<a name="line173"></a>      // Old versions of WebKit (Safari 3, Chrome 1) incorrectly match /u00A0
<a name="line174"></a>      // and newer versions properly match &amp;nbsp;.
<a name="line175"></a>      var nbspRegExp = goog.userAgent.isVersion(&#39;528&#39;) ? /&amp;nbsp;/g : /\u00A0/g;
<a name="line176"></a>      return text.replace(nbspRegExp, &#39; &#39;);
<a name="line177"></a>    });
<a name="line178"></a>  }
<a name="line179"></a>};
<a name="line180"></a>
<a name="line181"></a>
<a name="line182"></a>/**
<a name="line183"></a> * Finds the nearest ancestor of the node that is a table.
<a name="line184"></a> * @param {Node} nodeToCheck Node to search from.
<a name="line185"></a> * @return {Node} The table, or null if one was not found.
<a name="line186"></a> * @private
<a name="line187"></a> */
<a name="line188"></a>goog.editor.plugins.RemoveFormatting.getTableAncestor_ = function(nodeToCheck) {
<a name="line189"></a>  return goog.dom.getAncestor(nodeToCheck,
<a name="line190"></a>      function(node) { return node.tagName == goog.dom.TagName.TABLE; }, true);
<a name="line191"></a>};
<a name="line192"></a>
<a name="line193"></a>
<a name="line194"></a>/**
<a name="line195"></a> * Replaces the contents of the selection with html. Does its best to maintain
<a name="line196"></a> * the original selection. Also does its best to result in a valid DOM.
<a name="line197"></a> *
<a name="line198"></a> * TODO(user): See if there&#39;s any way to make this work on Ranges, and then
<a name="line199"></a> * move it into goog.editor.range. The Firefox implementation uses execCommand
<a name="line200"></a> * on the document, so must work on the actual selection.
<a name="line201"></a> *
<a name="line202"></a> * @param {string} html The html string to insert into the range.
<a name="line203"></a> * @private
<a name="line204"></a> */
<a name="line205"></a>goog.editor.plugins.RemoveFormatting.prototype.pasteHtml_ = function(html) {
<a name="line206"></a>  var range = this.fieldObject.getRange();
<a name="line207"></a>
<a name="line208"></a>  var dh = this.getFieldDomHelper();
<a name="line209"></a>  // Use markers to set the extent of the selection so that we can reselect it
<a name="line210"></a>  // afterwards. This works better than builtin range manipulation in FF and IE
<a name="line211"></a>  // because their implementations are so self-inconsistent and buggy.
<a name="line212"></a>  var startSpanId = goog.string.createUniqueString();
<a name="line213"></a>  var endSpanId = goog.string.createUniqueString();
<a name="line214"></a>  html = &#39;&lt;span id=&quot;&#39; + startSpanId + &#39;&quot;&gt;&lt;/span&gt;&#39; + html +
<a name="line215"></a>      &#39;&lt;span id=&quot;&#39; + endSpanId + &#39;&quot;&gt;&lt;/span&gt;&#39;;
<a name="line216"></a>  var dummyNodeId = goog.string.createUniqueString();
<a name="line217"></a>  var dummySpanText = &#39;&lt;span id=&quot;&#39; + dummyNodeId + &#39;&quot;&gt;&lt;/span&gt;&#39;;
<a name="line218"></a>
<a name="line219"></a>  if (goog.editor.BrowserFeature.HAS_IE_RANGES) {
<a name="line220"></a>    // IE&#39;s selection often doesn&#39;t include the outermost tags.
<a name="line221"></a>    // We want to use pasteHTML to replace the range contents with the newly
<a name="line222"></a>    // unformatted text, so we have to check to make sure we aren&#39;t just
<a name="line223"></a>    // pasting into some stray tags.  To do this, we first clear out the
<a name="line224"></a>    // contents of the range and then delete all empty nodes parenting the now
<a name="line225"></a>    // empty range. This way, the pasted contents are never re-embedded into
<a name="line226"></a>    // formated nodes. Pasting purely empty html does not work, since IE moves
<a name="line227"></a>    // the selection inside the next node, so we insert a dummy span.
<a name="line228"></a>    var textRange = range.getTextRange(0).getBrowserRangeObject();
<a name="line229"></a>    textRange.pasteHTML(dummySpanText);
<a name="line230"></a>    var parent;
<a name="line231"></a>    while ((parent = textRange.parentElement()) &amp;&amp;
<a name="line232"></a>           goog.editor.node.isEmpty(parent) &amp;&amp;
<a name="line233"></a>           !goog.editor.node.isEditableContainer(parent)) {
<a name="line234"></a>      var tag = parent.nodeName;
<a name="line235"></a>      // We can&#39;t remove these table tags as it will invalidate the table dom.
<a name="line236"></a>      if (tag == goog.dom.TagName.TD ||
<a name="line237"></a>          tag == goog.dom.TagName.TR ||
<a name="line238"></a>          tag == goog.dom.TagName.TH) {
<a name="line239"></a>        break;
<a name="line240"></a>      }
<a name="line241"></a>
<a name="line242"></a>      goog.dom.removeNode(parent);
<a name="line243"></a>    }
<a name="line244"></a>    textRange.pasteHTML(html);
<a name="line245"></a>    var dummySpan = dh.getElement(dummyNodeId);
<a name="line246"></a>    // If we entered the while loop above, the node has already been removed
<a name="line247"></a>    // since it was a child of parent and parent was removed.
<a name="line248"></a>    if (dummySpan) {
<a name="line249"></a>      goog.dom.removeNode(dummySpan);
<a name="line250"></a>    }
<a name="line251"></a>  } else if (goog.editor.BrowserFeature.HAS_W3C_RANGES) {
<a name="line252"></a>    // insertHtml and range.insertNode don&#39;t merge blocks correctly.
<a name="line253"></a>    // (e.g. if your selection spans two paragraphs)
<a name="line254"></a>    dh.getDocument().execCommand(&#39;insertImage&#39;, false, dummyNodeId);
<a name="line255"></a>    var dummyImageNodePattern = new RegExp(&#39;&lt;[^&lt;]*&#39; + dummyNodeId + &#39;[^&gt;]*&gt;&#39;);
<a name="line256"></a>    var parent = this.fieldObject.getRange().getContainerElement();
<a name="line257"></a>    if (parent.nodeType == goog.dom.NodeType.TEXT) {
<a name="line258"></a>      // Opera sometimes returns a text node here.
<a name="line259"></a>      // TODO(user): perhaps we should modify getParentContainer?
<a name="line260"></a>      parent = parent.parentNode;
<a name="line261"></a>    }
<a name="line262"></a>
<a name="line263"></a>    // We have to search up the DOM because in some cases, notably when
<a name="line264"></a>    // selecting li&#39;s within a list, execCommand(&#39;insertImage&#39;) actually splits
<a name="line265"></a>    // tags in such a way that parent that used to contain the selection does
<a name="line266"></a>    // not contain inserted image.
<a name="line267"></a>    while (!dummyImageNodePattern.test(parent.innerHTML)) {
<a name="line268"></a>      parent = parent.parentNode;
<a name="line269"></a>    }
<a name="line270"></a>
<a name="line271"></a>    // Like the IE case above, sometimes the selection does not include the
<a name="line272"></a>    // outermost tags.  For Gecko, we have already expanded the range so that
<a name="line273"></a>    // it does, so we can just replace the dummy image with the final html.
<a name="line274"></a>    // For WebKit, we use the same approach as we do with IE  - we
<a name="line275"></a>    // inject a dummy span where we will eventually place the contents, and
<a name="line276"></a>    // remove parentNodes of the span while they are empty.
<a name="line277"></a>
<a name="line278"></a>    if (goog.userAgent.GECKO) {
<a name="line279"></a>      parent.innerHTML =
<a name="line280"></a>          parent.innerHTML.replace(dummyImageNodePattern, html);
<a name="line281"></a>    } else {
<a name="line282"></a>      parent.innerHTML =
<a name="line283"></a>          parent.innerHTML.replace(dummyImageNodePattern, dummySpanText);
<a name="line284"></a>      var dummySpan = dh.getElement(dummyNodeId);
<a name="line285"></a>      parent = dummySpan;
<a name="line286"></a>      while ((parent = dummySpan.parentNode) &amp;&amp;
<a name="line287"></a>             goog.editor.node.isEmpty(parent) &amp;&amp;
<a name="line288"></a>             !goog.editor.node.isEditableContainer(parent)) {
<a name="line289"></a>        var tag = parent.nodeName;
<a name="line290"></a>        // We can&#39;t remove these table tags as it will invalidate the table dom.
<a name="line291"></a>        if (tag == goog.dom.TagName.TD ||
<a name="line292"></a>            tag == goog.dom.TagName.TR ||
<a name="line293"></a>            tag == goog.dom.TagName.TH) {
<a name="line294"></a>          break;
<a name="line295"></a>        }
<a name="line296"></a>
<a name="line297"></a>        // We can&#39;t just remove parent since dummySpan is inside it, and we need
<a name="line298"></a>        // to keep dummy span around for the replacement.  So we move the
<a name="line299"></a>        // dummySpan up as we go.
<a name="line300"></a>        goog.dom.insertSiblingAfter(dummySpan, parent);
<a name="line301"></a>        goog.dom.removeNode(parent);
<a name="line302"></a>      }
<a name="line303"></a>      parent.innerHTML =
<a name="line304"></a>          parent.innerHTML.replace(new RegExp(dummySpanText, &#39;i&#39;), html);
<a name="line305"></a>    }
<a name="line306"></a>  }
<a name="line307"></a>
<a name="line308"></a>  var startSpan = dh.getElement(startSpanId);
<a name="line309"></a>  var endSpan = dh.getElement(endSpanId);
<a name="line310"></a>  goog.dom.Range.createFromNodes(startSpan, 0, endSpan,
<a name="line311"></a>      endSpan.childNodes.length).select();
<a name="line312"></a>  goog.dom.removeNode(startSpan);
<a name="line313"></a>  goog.dom.removeNode(endSpan);
<a name="line314"></a>};
<a name="line315"></a>
<a name="line316"></a>
<a name="line317"></a>/**
<a name="line318"></a> * Gets the html inside the selection to send off for further processing.
<a name="line319"></a> *
<a name="line320"></a> * TODO(user): Make this general so that it can be moved into
<a name="line321"></a> * goog.editor.range.  The main reason it can&#39;t be moved is becuase we need to
<a name="line322"></a> * get the range before we do the execCommand and continue to operate on that
<a name="line323"></a> * same range (reasons are documented above).
<a name="line324"></a> *
<a name="line325"></a> * @param {goog.dom.AbstractRange} range The selection.
<a name="line326"></a> * @return {string} The html string to format.
<a name="line327"></a> * @private
<a name="line328"></a> */
<a name="line329"></a>goog.editor.plugins.RemoveFormatting.prototype.getHtmlText_ = function(range) {
<a name="line330"></a>  var div = this.getFieldDomHelper().createDom(&#39;div&#39;);
<a name="line331"></a>  var textRange = range.getBrowserRangeObject();
<a name="line332"></a>
<a name="line333"></a>  if (goog.editor.BrowserFeature.HAS_W3C_RANGES) {
<a name="line334"></a>    // Get the text to convert.
<a name="line335"></a>    div.appendChild(textRange.cloneContents());
<a name="line336"></a>  } else if (goog.editor.BrowserFeature.HAS_IE_RANGES) {
<a name="line337"></a>    // Trim the whitespace on the ends of the range, so that it the container
<a name="line338"></a>    // will be the container of only the text content that we are changing.
<a name="line339"></a>    // This gets around issues in IE where the spaces are included in the
<a name="line340"></a>    // selection, but ignored sometimes by execCommand, and left orphaned.
<a name="line341"></a>    var rngText = range.getText();
<a name="line342"></a>
<a name="line343"></a>    // BRs get reported as \r\n, but only count as one character for moves.
<a name="line344"></a>    // Adjust the string so our move counter is correct.
<a name="line345"></a>    rngText = rngText.replace(/\r\n/g, &#39;\r&#39;);
<a name="line346"></a>
<a name="line347"></a>    var rngTextLength = rngText.length;
<a name="line348"></a>    var left = rngTextLength - goog.string.trimLeft(rngText).length;
<a name="line349"></a>    var right = rngTextLength - goog.string.trimRight(rngText).length;
<a name="line350"></a>
<a name="line351"></a>    textRange.moveStart(&#39;character&#39;, left);
<a name="line352"></a>    textRange.moveEnd(&#39;character&#39;, -right);
<a name="line353"></a>
<a name="line354"></a>    var htmlText = textRange.htmlText;
<a name="line355"></a>    // Check if in pretag and fix up formatting so that new lines are preserved.
<a name="line356"></a>    if (textRange.queryCommandValue(&#39;formatBlock&#39;) == &#39;Formatted&#39;) {
<a name="line357"></a>      htmlText = goog.string.newLineToBr(textRange.htmlText);
<a name="line358"></a>    }
<a name="line359"></a>    div.innerHTML = htmlText;
<a name="line360"></a>  }
<a name="line361"></a>
<a name="line362"></a>  // Get the innerHTML of the node instead of just returning the text above
<a name="line363"></a>  // so that its properly html escaped.
<a name="line364"></a>  return div.innerHTML;
<a name="line365"></a>};
<a name="line366"></a>
<a name="line367"></a>
<a name="line368"></a>/**
<a name="line369"></a> * Move the range so that it doesn&#39;t include any partially selected tables.
<a name="line370"></a> * @param {goog.dom.AbstractRange} range The range to adjust.
<a name="line371"></a> * @param {Node} startInTable Table node that the range starts in.
<a name="line372"></a> * @param {Node} endInTable Table node that the range ends in.
<a name="line373"></a> * @return {goog.dom.SavedCaretRange} Range to use to restore the
<a name="line374"></a> *     selection after we run our custom remove formatting.
<a name="line375"></a> * @private
<a name="line376"></a> */
<a name="line377"></a>goog.editor.plugins.RemoveFormatting.prototype.adjustRangeForTables_ =
<a name="line378"></a>    function(range, startInTable, endInTable) {
<a name="line379"></a>  // Create placeholders for the current selection so we can restore it
<a name="line380"></a>  // later.
<a name="line381"></a>  var savedCaretRange = goog.editor.range.saveUsingNormalizedCarets(range);
<a name="line382"></a>
<a name="line383"></a>  var startNode = range.getStartNode();
<a name="line384"></a>  var startOffset = range.getStartOffset();
<a name="line385"></a>  var endNode = range.getEndNode();
<a name="line386"></a>  var endOffset = range.getEndOffset();
<a name="line387"></a>  var dh = this.getFieldDomHelper();
<a name="line388"></a>
<a name="line389"></a>  // Move start after the table.
<a name="line390"></a>  if (startInTable) {
<a name="line391"></a>    var textNode = dh.createTextNode(&#39;&#39;);
<a name="line392"></a>    goog.dom.insertSiblingAfter(textNode, startInTable);
<a name="line393"></a>    startNode = textNode;
<a name="line394"></a>    startOffset = 0;
<a name="line395"></a>  }
<a name="line396"></a>  // Move end before the table.
<a name="line397"></a>  if (endInTable) {
<a name="line398"></a>    var textNode = dh.createTextNode(&#39;&#39;);
<a name="line399"></a>    goog.dom.insertSiblingBefore(textNode, endInTable);
<a name="line400"></a>    endNode = textNode;
<a name="line401"></a>    endOffset = 0;
<a name="line402"></a>  }
<a name="line403"></a>
<a name="line404"></a>  goog.dom.Range.createFromNodes(startNode, startOffset,
<a name="line405"></a>      endNode, endOffset).select();
<a name="line406"></a>
<a name="line407"></a>  return savedCaretRange;
<a name="line408"></a>};
<a name="line409"></a>
<a name="line410"></a>
<a name="line411"></a>/**
<a name="line412"></a> * Remove a caret from the dom and hide it in a safe place, so it can
<a name="line413"></a> * be restored later via restoreCaretsFromCave.
<a name="line414"></a> * @param {goog.dom.SavedCaretRange} caretRange The caret range to
<a name="line415"></a> *     get the carets from.
<a name="line416"></a> * @param {boolean} isStart Whether this is the start or end caret.
<a name="line417"></a> * @private
<a name="line418"></a> */
<a name="line419"></a>goog.editor.plugins.RemoveFormatting.prototype.putCaretInCave_ = function(
<a name="line420"></a>    caretRange, isStart) {
<a name="line421"></a>  var cavedCaret = goog.dom.removeNode(caretRange.getCaret(isStart));
<a name="line422"></a>  if (isStart) {
<a name="line423"></a>    this.startCaretInCave_ = cavedCaret;
<a name="line424"></a>  } else {
<a name="line425"></a>    this.endCaretInCave_ = cavedCaret;
<a name="line426"></a>  }
<a name="line427"></a>};
<a name="line428"></a>
<a name="line429"></a>
<a name="line430"></a>/**
<a name="line431"></a> * Restore carets that were hidden away by adding them back into the dom.
<a name="line432"></a> * Note: this does not restore to the original dom location, as that
<a name="line433"></a> * will likely have been modified with remove formatting.  The only
<a name="line434"></a> * guarentees here are that start will still be before end, and that
<a name="line435"></a> * they will be in the editable region.  This should only be used when
<a name="line436"></a> * you don&#39;t actually intend to USE the caret again.
<a name="line437"></a> * @private
<a name="line438"></a> */
<a name="line439"></a>goog.editor.plugins.RemoveFormatting.prototype.restoreCaretsFromCave_ =
<a name="line440"></a>    function() {
<a name="line441"></a>  // To keep start before end, we put the end caret at the bottom of the field
<a name="line442"></a>  // and the start caret at the start of the field.
<a name="line443"></a>  var field = this.fieldObject.getElement();
<a name="line444"></a>  if (this.startCaretInCave_) {
<a name="line445"></a>    field.insertBefore(this.startCaretInCave_, field.firstChild);
<a name="line446"></a>    this.startCaretInCave_ = null;
<a name="line447"></a>  }
<a name="line448"></a>  if (this.endCaretInCave_) {
<a name="line449"></a>    field.appendChild(this.endCaretInCave_);
<a name="line450"></a>    this.endCaretInCave_ = null;
<a name="line451"></a>  }
<a name="line452"></a>};
<a name="line453"></a>
<a name="line454"></a>
<a name="line455"></a>/**
<a name="line456"></a> * Gets the html inside the current selection, passes it through the given
<a name="line457"></a> * conversion function, and puts it back into the selection.
<a name="line458"></a> *
<a name="line459"></a> * @param {function(string): string} convertFunc A conversion function that
<a name="line460"></a> *    transforms an html string to new html string.
<a name="line461"></a> * @private
<a name="line462"></a> */
<a name="line463"></a>goog.editor.plugins.RemoveFormatting.prototype.convertSelectedHtmlText_ =
<a name="line464"></a>    function(convertFunc) {
<a name="line465"></a>  var range = this.fieldObject.getRange();
<a name="line466"></a>
<a name="line467"></a>  // For multiple ranges, it is really hard to do our custom remove formatting
<a name="line468"></a>  // without invalidating other ranges. So instead of always losing the
<a name="line469"></a>  // content, this solution at least lets the browser do its own remove
<a name="line470"></a>  // formatting which works correctly most of the time.
<a name="line471"></a>  if (range.getTextRangeCount() &gt; 1) {
<a name="line472"></a>    return;
<a name="line473"></a>  }
<a name="line474"></a>
<a name="line475"></a>  if (goog.userAgent.GECKO) {
<a name="line476"></a>    // Determine if we need to handle tables, since they are special cases.
<a name="line477"></a>    // If the selection is entirely within a table, there is no extra
<a name="line478"></a>    // formatting removal we can do.  If a table is fully selected, we will
<a name="line479"></a>    // just blow it away. If a table is only partially selected, we can
<a name="line480"></a>    // perform custom remove formatting only on the non table parts, since we
<a name="line481"></a>    // we can&#39;t just remove the parts and paste back into it (eg. we can&#39;t
<a name="line482"></a>    // inject html where a TR used to be).
<a name="line483"></a>    // If the selection contains the table and more, this is automatically
<a name="line484"></a>    // handled, but if just the table is selected, it can be tricky to figure
<a name="line485"></a>    // this case out, because of the numerous ways selections can be formed -
<a name="line486"></a>    // ex. if a table has a single tr with a single td with a single text node
<a name="line487"></a>    // in it, and the selection is (textNode: 0), (textNode: nextNode.length)
<a name="line488"></a>    // then the entire table is selected, even though the start and end aren&#39;t
<a name="line489"></a>    // the table itself. We are truly inside a table if the expanded endpoints
<a name="line490"></a>    // are still inside the table.
<a name="line491"></a>
<a name="line492"></a>    // Expand the selection to include any outermost tags that weren&#39;t included
<a name="line493"></a>    // in the selection, but have the same visible selection. Stop expanding
<a name="line494"></a>    // if we reach the top level field.
<a name="line495"></a>    var expandedRange = goog.editor.range.expand(range,
<a name="line496"></a>        this.fieldObject.getElement());
<a name="line497"></a>
<a name="line498"></a>    var startInTable = goog.editor.plugins.RemoveFormatting.getTableAncestor_(
<a name="line499"></a>        expandedRange.getStartNode());
<a name="line500"></a>    var endInTable = goog.editor.plugins.RemoveFormatting.getTableAncestor_(
<a name="line501"></a>        expandedRange.getEndNode());
<a name="line502"></a>
<a name="line503"></a>    if (startInTable || endInTable) {
<a name="line504"></a>      if (startInTable == endInTable) {
<a name="line505"></a>        // We are fully contained in the same table, there is no extra
<a name="line506"></a>        // remove formatting that we can do, just return and run browser
<a name="line507"></a>        // formatting only.
<a name="line508"></a>        return;
<a name="line509"></a>      }
<a name="line510"></a>
<a name="line511"></a>      // Adjust the range to not contain any partially selected tables, since
<a name="line512"></a>      // we don&#39;t want to run our custom remove formatting on them.
<a name="line513"></a>      var savedCaretRange = this.adjustRangeForTables_(range,
<a name="line514"></a>          startInTable, endInTable);
<a name="line515"></a>
<a name="line516"></a>      // Hack alert!!
<a name="line517"></a>      // If start is not in a table, then the saved caret will get sent out
<a name="line518"></a>      // for uber remove formatting, and it will get blown away.  This is
<a name="line519"></a>      // fine, except that we need to be able to re-create a range from the
<a name="line520"></a>      // savedCaretRange later on.  So, we just remove it from the dom, and
<a name="line521"></a>      // put it back later so we can create a range later (not exactly in the
<a name="line522"></a>      // same spot, but don&#39;t worry we don&#39;t actually try to use it later)
<a name="line523"></a>      // and then it will be removed when we dispose the range.
<a name="line524"></a>      if (!startInTable) {
<a name="line525"></a>        this.putCaretInCave_(savedCaretRange, true);
<a name="line526"></a>      }
<a name="line527"></a>      if (!endInTable) {
<a name="line528"></a>        this.putCaretInCave_(savedCaretRange, false);
<a name="line529"></a>      }
<a name="line530"></a>
<a name="line531"></a>      // Re-fetch the range, and re-expand it, since we just modified it.
<a name="line532"></a>      range = this.fieldObject.getRange();
<a name="line533"></a>      expandedRange = goog.editor.range.expand(range,
<a name="line534"></a>          this.fieldObject.getElement());
<a name="line535"></a>    }
<a name="line536"></a>
<a name="line537"></a>    expandedRange.select();
<a name="line538"></a>    range = expandedRange;
<a name="line539"></a>  }
<a name="line540"></a>
<a name="line541"></a>  // Convert the selected text to the format-less version, paste back into
<a name="line542"></a>  // the selection.
<a name="line543"></a>  var text = this.getHtmlText_(range);
<a name="line544"></a>  this.pasteHtml_(convertFunc(text));
<a name="line545"></a>
<a name="line546"></a>  if (goog.userAgent.GECKO &amp;&amp; savedCaretRange) {
<a name="line547"></a>    // If we moved the selection, move it back so the user can&#39;t tell we did
<a name="line548"></a>    // anything crazy and so the browser removeFormat that we call next
<a name="line549"></a>    // will operate on the entire originally selected range.
<a name="line550"></a>    range = this.fieldObject.getRange();
<a name="line551"></a>    this.restoreCaretsFromCave_();
<a name="line552"></a>    var realSavedCaretRange = savedCaretRange.toAbstractRange();
<a name="line553"></a>    var startRange = startInTable ? realSavedCaretRange : range;
<a name="line554"></a>    var endRange = endInTable ? realSavedCaretRange : range;
<a name="line555"></a>    var restoredRange =
<a name="line556"></a>        goog.editor.plugins.RemoveFormatting.createRangeDelimitedByRanges_(
<a name="line557"></a>            startRange, endRange);
<a name="line558"></a>    restoredRange.select();
<a name="line559"></a>    savedCaretRange.dispose();
<a name="line560"></a>  }
<a name="line561"></a>};
<a name="line562"></a>
<a name="line563"></a>
<a name="line564"></a>/**
<a name="line565"></a> * Does a best-effort attempt at clobbering all formatting that the
<a name="line566"></a> * browser&#39;s execCommand couldn&#39;t clobber without being totally inefficient.
<a name="line567"></a> * Attempts to convert visual line breaks to BRs. Leaves anchors that contain an
<a name="line568"></a> * href and images.
<a name="line569"></a> * Adapted from Gmail&#39;s MessageUtil&#39;s htmlToPlainText. http://go/messageutil.js
<a name="line570"></a> * @param {string} html The original html of the message.
<a name="line571"></a> * @return {string} The unformatted html, which is just text, br&#39;s, anchors and
<a name="line572"></a> *     images.
<a name="line573"></a> * @private
<a name="line574"></a> */
<a name="line575"></a>goog.editor.plugins.RemoveFormatting.prototype.removeFormattingWorker_ =
<a name="line576"></a>    function(html) {
<a name="line577"></a>  var el = goog.dom.createElement(&#39;div&#39;);
<a name="line578"></a>  el.innerHTML = html;
<a name="line579"></a>
<a name="line580"></a>  // Put everything into a string buffer to avoid lots of expensive string
<a name="line581"></a>  // concatenation along the way.
<a name="line582"></a>  var sb = [];
<a name="line583"></a>  var stack = [el.childNodes, 0];
<a name="line584"></a>
<a name="line585"></a>  // Keep separate stacks for places where we need to keep track of
<a name="line586"></a>  // how deeply embedded we are.  These are analogous to the general stack.
<a name="line587"></a>  var preTagStack = [];
<a name="line588"></a>  var preTagLevel = 0;  // Length of the prestack.
<a name="line589"></a>  var tableStack = [];
<a name="line590"></a>  var tableLevel = 0;
<a name="line591"></a>
<a name="line592"></a>  // sp = stack pointer, pointing to the stack array.
<a name="line593"></a>  // decrement by 2 since the stack alternates node lists and
<a name="line594"></a>  // processed node counts
<a name="line595"></a>  for (var sp = 0; sp &gt;= 0; sp -= 2) {
<a name="line596"></a>    // Check if we should pop the table level.
<a name="line597"></a>    var changedLevel = false;
<a name="line598"></a>    while (tableLevel &gt; 0 &amp;&amp; sp &lt;= tableStack[tableLevel - 1]) {
<a name="line599"></a>      tableLevel--;
<a name="line600"></a>      changedLevel = true;
<a name="line601"></a>    }
<a name="line602"></a>    if (changedLevel) {
<a name="line603"></a>      goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line604"></a>    }
<a name="line605"></a>
<a name="line606"></a>
<a name="line607"></a>    // Check if we should pop the &lt;pre&gt;/&lt;xmp&gt; level.
<a name="line608"></a>    changedLevel = false;
<a name="line609"></a>    while (preTagLevel &gt; 0 &amp;&amp; sp &lt;= preTagStack[preTagLevel - 1]) {
<a name="line610"></a>      preTagLevel--;
<a name="line611"></a>      changedLevel = true;
<a name="line612"></a>    }
<a name="line613"></a>    if (changedLevel) {
<a name="line614"></a>      goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line615"></a>    }
<a name="line616"></a>
<a name="line617"></a>    // The list of of nodes to process at the current stack level.
<a name="line618"></a>    var nodeList = stack[sp];
<a name="line619"></a>    // The number of nodes processed so far, stored in the stack immediately
<a name="line620"></a>    // following the node list for that stack level.
<a name="line621"></a>    var numNodesProcessed = stack[sp + 1];
<a name="line622"></a>
<a name="line623"></a>    while (numNodesProcessed &lt; nodeList.length) {
<a name="line624"></a>      var node = nodeList[numNodesProcessed++];
<a name="line625"></a>      var nodeName = node.nodeName;
<a name="line626"></a>
<a name="line627"></a>      var formatted = this.getValueForNode(node);
<a name="line628"></a>      if (goog.isDefAndNotNull(formatted)) {
<a name="line629"></a>        sb.push(formatted);
<a name="line630"></a>        continue;
<a name="line631"></a>      }
<a name="line632"></a>
<a name="line633"></a>      // TODO(user): Handle case &#39;EMBED&#39; and case &#39;OBJECT&#39;.
<a name="line634"></a>      switch (nodeName) {
<a name="line635"></a>        case &#39;#text&#39;:
<a name="line636"></a>          // Note that IE does not preserve whitespace in the dom
<a name="line637"></a>          // values, even in a pre tag, so this is useless for IE.
<a name="line638"></a>          var nodeValue = preTagLevel &gt; 0 ?
<a name="line639"></a>              node.nodeValue :
<a name="line640"></a>              goog.string.stripNewlines(node.nodeValue);
<a name="line641"></a>          nodeValue = goog.string.htmlEscape(nodeValue);
<a name="line642"></a>          sb.push(nodeValue);
<a name="line643"></a>          continue;
<a name="line644"></a>
<a name="line645"></a>        case goog.dom.TagName.P:
<a name="line646"></a>          goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line647"></a>          goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line648"></a>          break;  // break (not continue) so that child nodes are processed.
<a name="line649"></a>
<a name="line650"></a>        case goog.dom.TagName.BR:
<a name="line651"></a>          goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line652"></a>          continue;
<a name="line653"></a>
<a name="line654"></a>        case goog.dom.TagName.TABLE:
<a name="line655"></a>          goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line656"></a>          tableStack[tableLevel++] = sp;
<a name="line657"></a>          break;
<a name="line658"></a>
<a name="line659"></a>        case goog.dom.TagName.PRE:
<a name="line660"></a>        case &#39;XMP&#39;:
<a name="line661"></a>          // This doesn&#39;t fully handle xmp, since
<a name="line662"></a>          // it doesn&#39;t actually ignore tags within the xmp tag.
<a name="line663"></a>          preTagStack[preTagLevel++] = sp;
<a name="line664"></a>          break;
<a name="line665"></a>
<a name="line666"></a>        case goog.dom.TagName.STYLE:
<a name="line667"></a>        case goog.dom.TagName.SCRIPT:
<a name="line668"></a>        case goog.dom.TagName.SELECT:
<a name="line669"></a>          continue;
<a name="line670"></a>
<a name="line671"></a>        case goog.dom.TagName.A:
<a name="line672"></a>          if (node.href &amp;&amp; node.href != &#39;&#39;) {
<a name="line673"></a>            sb.push(&quot;&lt;a href=&#39;&quot;);
<a name="line674"></a>            sb.push(node.href);
<a name="line675"></a>            sb.push(&quot;&#39;&gt;&quot;);
<a name="line676"></a>            sb.push(this.removeFormattingWorker_(node.innerHTML));
<a name="line677"></a>            sb.push(&#39;&lt;/a&gt;&#39;);
<a name="line678"></a>            continue; // Children taken care of.
<a name="line679"></a>          } else {
<a name="line680"></a>            break; // Take care of the children.
<a name="line681"></a>          }
<a name="line682"></a>
<a name="line683"></a>        case goog.dom.TagName.IMG:
<a name="line684"></a>          sb.push(&quot;&lt;img src=&#39;&quot;);
<a name="line685"></a>          sb.push(node.src);
<a name="line686"></a>          sb.push(&quot;&#39;&quot;);
<a name="line687"></a>          // border=0 is a common way to not show a blue border around an image
<a name="line688"></a>          // that is wrapped by a link. If we remove that, the blue border will
<a name="line689"></a>          // show up, which to the user looks like adding format, not removing.
<a name="line690"></a>          if (node.border == &#39;0&#39;) {
<a name="line691"></a>            sb.push(&quot; border=&#39;0&#39;&quot;);
<a name="line692"></a>          }
<a name="line693"></a>          sb.push(&#39;&gt;&#39;);
<a name="line694"></a>          continue;
<a name="line695"></a>
<a name="line696"></a>        case goog.dom.TagName.TD:
<a name="line697"></a>          // Don&#39;t add a space for the first TD, we only want spaces to
<a name="line698"></a>          // separate td&#39;s.
<a name="line699"></a>          if (node.previousSibling) {
<a name="line700"></a>            sb.push(&#39; &#39;);
<a name="line701"></a>          }
<a name="line702"></a>          break;
<a name="line703"></a>
<a name="line704"></a>        case goog.dom.TagName.TR:
<a name="line705"></a>          // Don&#39;t add a newline for the first TR.
<a name="line706"></a>          if (node.previousSibling) {
<a name="line707"></a>            goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line708"></a>          }
<a name="line709"></a>          break;
<a name="line710"></a>
<a name="line711"></a>        case goog.dom.TagName.DIV:
<a name="line712"></a>          var parent = node.parentNode;
<a name="line713"></a>          if (parent.firstChild == node &amp;&amp;
<a name="line714"></a>              goog.editor.plugins.RemoveFormatting.BLOCK_RE_.test(
<a name="line715"></a>                  parent.tagName)) {
<a name="line716"></a>            // If a DIV is the first child of another element that itself is a
<a name="line717"></a>            // block element, the DIV does not add a new line.
<a name="line718"></a>            break;
<a name="line719"></a>          }
<a name="line720"></a>          // Otherwise, the DIV does add a new line.  Fall through.
<a name="line721"></a>
<a name="line722"></a>        default:
<a name="line723"></a>          if (goog.editor.plugins.RemoveFormatting.BLOCK_RE_.test(nodeName)) {
<a name="line724"></a>            goog.editor.plugins.RemoveFormatting.appendNewline_(sb);
<a name="line725"></a>          }
<a name="line726"></a>      }
<a name="line727"></a>
<a name="line728"></a>      // Recurse down the node.
<a name="line729"></a>      var children = node.childNodes;
<a name="line730"></a>      if (children.length &gt; 0) {
<a name="line731"></a>        // Push the current state on the stack.
<a name="line732"></a>        stack[sp++] = nodeList;
<a name="line733"></a>        stack[sp++] = numNodesProcessed;
<a name="line734"></a>
<a name="line735"></a>        // Iterate through the children nodes.
<a name="line736"></a>        nodeList = children;
<a name="line737"></a>        numNodesProcessed = 0;
<a name="line738"></a>      }
<a name="line739"></a>    }
<a name="line740"></a>  }
<a name="line741"></a>
<a name="line742"></a>  // Replace &amp;nbsp; with white space.
<a name="line743"></a>  return goog.string.normalizeSpaces(sb.join(&#39;&#39;));
<a name="line744"></a>};
<a name="line745"></a>
<a name="line746"></a>
<a name="line747"></a>/**
<a name="line748"></a> * Handle per node special processing if neccessary. If this function returns
<a name="line749"></a> * null then standard cleanup is applied. Otherwise this node and all children
<a name="line750"></a> * are assumed to be cleaned.
<a name="line751"></a> * NOTE(user): If an alternate RemoveFormatting processor is provided
<a name="line752"></a> * (setRemoveFormattingFunc()), this will no longer work.
<a name="line753"></a> * @param {Element} node The node to clean.
<a name="line754"></a> * @return {?string} The HTML strig representation of the cleaned data.
<a name="line755"></a> */
<a name="line756"></a>goog.editor.plugins.RemoveFormatting.prototype.getValueForNode = function(
<a name="line757"></a>    node) {
<a name="line758"></a>  return null;
<a name="line759"></a>};
<a name="line760"></a>
<a name="line761"></a>
<a name="line762"></a>/**
<a name="line763"></a> * Sets a function to be used for remove formatting.
<a name="line764"></a> * @param {function(string): string} removeFormattingFunc - A function that
<a name="line765"></a> *     takes  a string of html and returns a string of html that does any other
<a name="line766"></a> *     formatting changes desired.  Use this only if trogedit&#39;s behavior doesn&#39;t
<a name="line767"></a> *     meet your needs.
<a name="line768"></a> */
<a name="line769"></a>goog.editor.plugins.RemoveFormatting.prototype.setRemoveFormattingFunc =
<a name="line770"></a>    function(removeFormattingFunc) {
<a name="line771"></a>  this.optRemoveFormattingFunc_ = removeFormattingFunc;
<a name="line772"></a>};
</pre>


</body>
</html>
