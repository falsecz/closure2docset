<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>string.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="closure_goog_string_string.js.html">string.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2006 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Utilities for string manipulation.
<a name="line17"></a> */
<a name="line18"></a>
<a name="line19"></a>
<a name="line20"></a>/**
<a name="line21"></a> * Namespace for string utilities
<a name="line22"></a> */
<a name="line23"></a>goog.provide(&#39;goog.string&#39;);
<a name="line24"></a>goog.provide(&#39;goog.string.Unicode&#39;);
<a name="line25"></a>
<a name="line26"></a>
<a name="line27"></a>/**
<a name="line28"></a> * Common Unicode string characters.
<a name="line29"></a> * @enum {string}
<a name="line30"></a> */
<a name="line31"></a>goog.string.Unicode = {
<a name="line32"></a>  NBSP: &#39;\xa0&#39;
<a name="line33"></a>};
<a name="line34"></a>
<a name="line35"></a>
<a name="line36"></a>/**
<a name="line37"></a> * Fast prefix-checker.
<a name="line38"></a> * @param {string} str The string to check.
<a name="line39"></a> * @param {string} prefix A string to look for at the start of {@code str}.
<a name="line40"></a> * @return {boolean} True if {@code str} begins with {@code prefix}.
<a name="line41"></a> */
<a name="line42"></a>goog.string.startsWith = function(str, prefix) {
<a name="line43"></a>  return str.lastIndexOf(prefix, 0) == 0;
<a name="line44"></a>};
<a name="line45"></a>
<a name="line46"></a>
<a name="line47"></a>/**
<a name="line48"></a> * Fast suffix-checker.
<a name="line49"></a> * @param {string} str The string to check.
<a name="line50"></a> * @param {string} suffix A string to look for at the end of {@code str}.
<a name="line51"></a> * @return {boolean} True if {@code str} ends with {@code suffix}.
<a name="line52"></a> */
<a name="line53"></a>goog.string.endsWith = function(str, suffix) {
<a name="line54"></a>  var l = str.length - suffix.length;
<a name="line55"></a>  return l &gt;= 0 &amp;&amp; str.indexOf(suffix, l) == l;
<a name="line56"></a>};
<a name="line57"></a>
<a name="line58"></a>
<a name="line59"></a>/**
<a name="line60"></a> * Case-insensitive prefix-checker.
<a name="line61"></a> * @param {string} str The string to check.
<a name="line62"></a> * @param {string} prefix  A string to look for at the end of {@code str}.
<a name="line63"></a> * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
<a name="line64"></a> *     case).
<a name="line65"></a> */
<a name="line66"></a>goog.string.caseInsensitiveStartsWith = function(str, prefix) {
<a name="line67"></a>  return goog.string.caseInsensitiveCompare(
<a name="line68"></a>      prefix, str.substr(0, prefix.length)) == 0;
<a name="line69"></a>};
<a name="line70"></a>
<a name="line71"></a>
<a name="line72"></a>/**
<a name="line73"></a> * Case-insensitive suffix-checker.
<a name="line74"></a> * @param {string} str The string to check.
<a name="line75"></a> * @param {string} suffix A string to look for at the end of {@code str}.
<a name="line76"></a> * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
<a name="line77"></a> *     case).
<a name="line78"></a> */
<a name="line79"></a>goog.string.caseInsensitiveEndsWith = function(str, suffix) {
<a name="line80"></a>  return goog.string.caseInsensitiveCompare(
<a name="line81"></a>      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
<a name="line82"></a>};
<a name="line83"></a>
<a name="line84"></a>
<a name="line85"></a>/**
<a name="line86"></a> * Does simple python-style string substitution.
<a name="line87"></a> * subs(&quot;foo%s hot%s&quot;, &quot;bar&quot;, &quot;dog&quot;) becomes &quot;foobar hotdog&quot;.
<a name="line88"></a> * @param {string} str The string containing the pattern.
<a name="line89"></a> * @param {...*} var_args The items to substitute into the pattern.
<a name="line90"></a> * @return {string} A copy of {@code str} in which each occurrence of
<a name="line91"></a> *     {@code %s} has been replaced an argument from {@code var_args}.
<a name="line92"></a> */
<a name="line93"></a>goog.string.subs = function(str, var_args) {
<a name="line94"></a>  // This appears to be slow, but testing shows it compares more or less
<a name="line95"></a>  // equivalent to the regex.exec method.
<a name="line96"></a>  for (var i = 1; i &lt; arguments.length; i++) {
<a name="line97"></a>    // We cast to String in case an argument is a Function.  Replacing $&amp;, for
<a name="line98"></a>    // example, with $$$&amp; stops the replace from subsituting the whole match
<a name="line99"></a>    // into the resultant string.  $$$&amp; in the first replace becomes $$&amp; in the
<a name="line100"></a>    //  second, which leaves $&amp; in the resultant string.  Also:
<a name="line101"></a>    // $$, $`, $&#39;, $n $nn
<a name="line102"></a>    var replacement = String(arguments[i]).replace(/\$/g, &#39;$$$$&#39;);
<a name="line103"></a>    str = str.replace(/\%s/, replacement);
<a name="line104"></a>  }
<a name="line105"></a>  return str;
<a name="line106"></a>};
<a name="line107"></a>
<a name="line108"></a>
<a name="line109"></a>/**
<a name="line110"></a> * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
<a name="line111"></a> * and tabs) to a single space, and strips leading and trailing whitespace.
<a name="line112"></a> * @param {string} str Input string.
<a name="line113"></a> * @return {string} A copy of {@code str} with collapsed whitespace.
<a name="line114"></a> */
<a name="line115"></a>goog.string.collapseWhitespace = function(str) {
<a name="line116"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line117"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line118"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line119"></a>  return str.replace(/[\s\xa0]+/g, &#39; &#39;).replace(/^\s+|\s+$/g, &#39;&#39;);
<a name="line120"></a>};
<a name="line121"></a>
<a name="line122"></a>
<a name="line123"></a>/**
<a name="line124"></a> * Checks if a string is empty or contains only whitespaces.
<a name="line125"></a> * @param {string} str The string to check.
<a name="line126"></a> * @return {boolean} True if {@code str} is empty or whitespace only.
<a name="line127"></a> */
<a name="line128"></a>goog.string.isEmpty = function(str) {
<a name="line129"></a>  // testing length == 0 first is actually slower in all browsers (about the
<a name="line130"></a>  // same in Opera).
<a name="line131"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line132"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line133"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line134"></a>  return /^[\s\xa0]*$/.test(str);
<a name="line135"></a>};
<a name="line136"></a>
<a name="line137"></a>
<a name="line138"></a>/**
<a name="line139"></a> * Checks if a string is null, empty or contains only whitespaces.
<a name="line140"></a> * @param {*} str The string to check.
<a name="line141"></a> * @return {boolean} True if{@code str} is null, empty, or whitespace only.
<a name="line142"></a> */
<a name="line143"></a>goog.string.isEmptySafe = function(str) {
<a name="line144"></a>  return goog.string.isEmpty(goog.string.makeSafe(str));
<a name="line145"></a>};
<a name="line146"></a>
<a name="line147"></a>
<a name="line148"></a>/**
<a name="line149"></a> * Checks if a string is all breaking whitespace.
<a name="line150"></a> * @param {string} str The string to check.
<a name="line151"></a> * @return {boolean} Whether the string is all breaking whitespace.
<a name="line152"></a> */
<a name="line153"></a>goog.string.isBreakingWhitespace = function(str) {
<a name="line154"></a>  return !/[^\t\n\r ]/.test(str);
<a name="line155"></a>};
<a name="line156"></a>
<a name="line157"></a>
<a name="line158"></a>/**
<a name="line159"></a> * Checks if a string contains all letters.
<a name="line160"></a> * @param {string} str string to check.
<a name="line161"></a> * @return {boolean} True if {@code str} consists entirely of letters.
<a name="line162"></a> */
<a name="line163"></a>goog.string.isAlpha = function(str) {
<a name="line164"></a>  return !/[^a-zA-Z]/.test(str);
<a name="line165"></a>};
<a name="line166"></a>
<a name="line167"></a>
<a name="line168"></a>/**
<a name="line169"></a> * Checks if a string contains only numbers.
<a name="line170"></a> * @param {*} str string to check. If not a string, it will be
<a name="line171"></a> *     casted to one.
<a name="line172"></a> * @return {boolean} True if {@code str} is numeric.
<a name="line173"></a> */
<a name="line174"></a>goog.string.isNumeric = function(str) {
<a name="line175"></a>  return !/[^0-9]/.test(str);
<a name="line176"></a>};
<a name="line177"></a>
<a name="line178"></a>
<a name="line179"></a>/**
<a name="line180"></a> * Checks if a string contains only numbers or letters.
<a name="line181"></a> * @param {string} str string to check.
<a name="line182"></a> * @return {boolean} True if {@code str} is alphanumeric.
<a name="line183"></a> */
<a name="line184"></a>goog.string.isAlphaNumeric = function(str) {
<a name="line185"></a>  return !/[^a-zA-Z0-9]/.test(str);
<a name="line186"></a>};
<a name="line187"></a>
<a name="line188"></a>
<a name="line189"></a>/**
<a name="line190"></a> * Checks if a character is a space character.
<a name="line191"></a> * @param {string} ch Character to check.
<a name="line192"></a> * @return {boolean} True if {code ch} is a space.
<a name="line193"></a> */
<a name="line194"></a>goog.string.isSpace = function(ch) {
<a name="line195"></a>  return ch == &#39; &#39;;
<a name="line196"></a>};
<a name="line197"></a>
<a name="line198"></a>
<a name="line199"></a>/**
<a name="line200"></a> * Checks if a character is a valid unicode character.
<a name="line201"></a> * @param {string} ch Character to check.
<a name="line202"></a> * @return {boolean} True if {code ch} is a valid unicode character.
<a name="line203"></a> */
<a name="line204"></a>goog.string.isUnicodeChar = function(ch) {
<a name="line205"></a>  return ch.length == 1 &amp;&amp; ch &gt;= &#39; &#39; &amp;&amp; ch &lt;= &#39;~&#39; ||
<a name="line206"></a>         ch &gt;= &#39;\u0080&#39; &amp;&amp; ch &lt;= &#39;\uFFFD&#39;;
<a name="line207"></a>};
<a name="line208"></a>
<a name="line209"></a>
<a name="line210"></a>/**
<a name="line211"></a> * Takes a string and replaces newlines with a space. Multiple lines are
<a name="line212"></a> * replaced with a single space.
<a name="line213"></a> * @param {string} str The string from which to strip newlines.
<a name="line214"></a> * @return {string} A copy of {@code str} stripped of newlines.
<a name="line215"></a> */
<a name="line216"></a>goog.string.stripNewlines = function(str) {
<a name="line217"></a>  return str.replace(/(\r\n|\r|\n)+/g, &#39; &#39;);
<a name="line218"></a>};
<a name="line219"></a>
<a name="line220"></a>
<a name="line221"></a>/**
<a name="line222"></a> * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
<a name="line223"></a> * @param {string} str The string to in which to canonicalize newlines.
<a name="line224"></a> * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
<a name="line225"></a> */
<a name="line226"></a>goog.string.canonicalizeNewlines = function(str) {
<a name="line227"></a>  return str.replace(/(\r\n|\r|\n)/g, &#39;\n&#39;);
<a name="line228"></a>};
<a name="line229"></a>
<a name="line230"></a>
<a name="line231"></a>/**
<a name="line232"></a> * Normalizes whitespace in a string, replacing all whitespace chars with
<a name="line233"></a> * a space.
<a name="line234"></a> * @param {string} str The string in which to normalize whitespace.
<a name="line235"></a> * @return {string} A copy of {@code str} with all whitespace normalized.
<a name="line236"></a> */
<a name="line237"></a>goog.string.normalizeWhitespace = function(str) {
<a name="line238"></a>  return str.replace(/\xa0|\s/g, &#39; &#39;);
<a name="line239"></a>};
<a name="line240"></a>
<a name="line241"></a>
<a name="line242"></a>/**
<a name="line243"></a> * Normalizes spaces in a string, replacing all consecutive spaces and tabs
<a name="line244"></a> * with a single space. Replaces non-breaking space with a space.
<a name="line245"></a> * @param {string} str The string in which to normalize spaces.
<a name="line246"></a> * @return {string} A copy of {@code str} with all consecutive spaces and tabs
<a name="line247"></a> *    replaced with a single space.
<a name="line248"></a> */
<a name="line249"></a>goog.string.normalizeSpaces = function(str) {
<a name="line250"></a>  return str.replace(/\xa0|[ \t]+/g, &#39; &#39;);
<a name="line251"></a>};
<a name="line252"></a>
<a name="line253"></a>
<a name="line254"></a>/**
<a name="line255"></a> * Removes the breaking spaces from the left and right of the string and
<a name="line256"></a> * collapses the sequences of breaking spaces in the middle into single spaces.
<a name="line257"></a> * The original and the result strings render the same way in HTML.
<a name="line258"></a> * @param {string} str A string in which to collapse spaces.
<a name="line259"></a> * @return {string} Copy of the string with normalized breaking spaces.
<a name="line260"></a> */
<a name="line261"></a>goog.string.collapseBreakingSpaces = function(str) {
<a name="line262"></a>  return str.replace(/[\t\r\n ]+/g, &#39; &#39;).replace(
<a name="line263"></a>      /^[\t\r\n ]+|[\t\r\n ]+$/g, &#39;&#39;);
<a name="line264"></a>};
<a name="line265"></a>
<a name="line266"></a>
<a name="line267"></a>/**
<a name="line268"></a> * Trims white spaces to the left and right of a string.
<a name="line269"></a> * @param {string} str The string to trim.
<a name="line270"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line271"></a> */
<a name="line272"></a>goog.string.trim = function(str) {
<a name="line273"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line274"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line275"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line276"></a>  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, &#39;&#39;);
<a name="line277"></a>};
<a name="line278"></a>
<a name="line279"></a>
<a name="line280"></a>/**
<a name="line281"></a> * Trims whitespaces at the left end of a string.
<a name="line282"></a> * @param {string} str The string to left trim.
<a name="line283"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line284"></a> */
<a name="line285"></a>goog.string.trimLeft = function(str) {
<a name="line286"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line287"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line288"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line289"></a>  return str.replace(/^[\s\xa0]+/, &#39;&#39;);
<a name="line290"></a>};
<a name="line291"></a>
<a name="line292"></a>
<a name="line293"></a>/**
<a name="line294"></a> * Trims whitespaces at the right end of a string.
<a name="line295"></a> * @param {string} str The string to right trim.
<a name="line296"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line297"></a> */
<a name="line298"></a>goog.string.trimRight = function(str) {
<a name="line299"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line300"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line301"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line302"></a>  return str.replace(/[\s\xa0]+$/, &#39;&#39;);
<a name="line303"></a>};
<a name="line304"></a>
<a name="line305"></a>
<a name="line306"></a>/**
<a name="line307"></a> * A string comparator that ignores case.
<a name="line308"></a> * -1 = str1 less than str2
<a name="line309"></a> *  0 = str1 equals str2
<a name="line310"></a> *  1 = str1 greater than str2
<a name="line311"></a> *
<a name="line312"></a> * @param {string} str1 The string to compare.
<a name="line313"></a> * @param {string} str2 The string to compare {@code str1} to.
<a name="line314"></a> * @return {number} The comparator result, as described above.
<a name="line315"></a> */
<a name="line316"></a>goog.string.caseInsensitiveCompare = function(str1, str2) {
<a name="line317"></a>  var test1 = String(str1).toLowerCase();
<a name="line318"></a>  var test2 = String(str2).toLowerCase();
<a name="line319"></a>
<a name="line320"></a>  if (test1 &lt; test2) {
<a name="line321"></a>    return -1;
<a name="line322"></a>  } else if (test1 == test2) {
<a name="line323"></a>    return 0;
<a name="line324"></a>  } else {
<a name="line325"></a>    return 1;
<a name="line326"></a>  }
<a name="line327"></a>};
<a name="line328"></a>
<a name="line329"></a>
<a name="line330"></a>/**
<a name="line331"></a> * Regular expression used for splitting a string into substrings of fractional
<a name="line332"></a> * numbers, integers, and non-numeric characters.
<a name="line333"></a> * @type {RegExp}
<a name="line334"></a> * @private
<a name="line335"></a> */
<a name="line336"></a>goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
<a name="line337"></a>
<a name="line338"></a>
<a name="line339"></a>/**
<a name="line340"></a> * String comparison function that handles numbers in a way humans might expect.
<a name="line341"></a> * Using this function, the string &quot;File 2.jpg&quot; sorts before &quot;File 10.jpg&quot;. The
<a name="line342"></a> * comparison is mostly case-insensitive, though strings that are identical
<a name="line343"></a> * except for case are sorted with the upper-case strings before lower-case.
<a name="line344"></a> *
<a name="line345"></a> * This comparison function is significantly slower (about 500x) than either
<a name="line346"></a> * the default or the case-insensitive compare. It should not be used in
<a name="line347"></a> * time-critical code, but should be fast enough to sort several hundred short
<a name="line348"></a> * strings (like filenames) with a reasonable delay.
<a name="line349"></a> *
<a name="line350"></a> * @param {string} str1 The string to compare in a numerically sensitive way.
<a name="line351"></a> * @param {string} str2 The string to compare {@code str1} to.
<a name="line352"></a> * @return {number} less than 0 if str1 &lt; str2, 0 if str1 == str2, greater than
<a name="line353"></a> *     0 if str1 &gt; str2.
<a name="line354"></a> */
<a name="line355"></a>goog.string.numerateCompare = function(str1, str2) {
<a name="line356"></a>  if (str1 == str2) {
<a name="line357"></a>    return 0;
<a name="line358"></a>  }
<a name="line359"></a>  if (!str1) {
<a name="line360"></a>    return -1;
<a name="line361"></a>  }
<a name="line362"></a>  if (!str2) {
<a name="line363"></a>    return 1;
<a name="line364"></a>  }
<a name="line365"></a>
<a name="line366"></a>  // Using match to split the entire string ahead of time turns out to be faster
<a name="line367"></a>  // for most inputs than using RegExp.exec or iterating over each character.
<a name="line368"></a>  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
<a name="line369"></a>  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);
<a name="line370"></a>
<a name="line371"></a>  var count = Math.min(tokens1.length, tokens2.length);
<a name="line372"></a>
<a name="line373"></a>  for (var i = 0; i &lt; count; i++) {
<a name="line374"></a>    var a = tokens1[i];
<a name="line375"></a>    var b = tokens2[i];
<a name="line376"></a>
<a name="line377"></a>    // Compare pairs of tokens, returning if one token sorts before the other.
<a name="line378"></a>    if (a != b) {
<a name="line379"></a>
<a name="line380"></a>      // Only if both tokens are integers is a special comparison required.
<a name="line381"></a>      // Decimal numbers are sorted as strings (e.g., &#39;.09&#39; &lt; &#39;.1&#39;).
<a name="line382"></a>      var num1 = parseInt(a, 10);
<a name="line383"></a>      if (!isNaN(num1)) {
<a name="line384"></a>        var num2 = parseInt(b, 10);
<a name="line385"></a>        if (!isNaN(num2) &amp;&amp; num1 - num2) {
<a name="line386"></a>          return num1 - num2;
<a name="line387"></a>        }
<a name="line388"></a>      }
<a name="line389"></a>      return a &lt; b ? -1 : 1;
<a name="line390"></a>    }
<a name="line391"></a>  }
<a name="line392"></a>
<a name="line393"></a>  // If one string is a substring of the other, the shorter string sorts first.
<a name="line394"></a>  if (tokens1.length != tokens2.length) {
<a name="line395"></a>    return tokens1.length - tokens2.length;
<a name="line396"></a>  }
<a name="line397"></a>
<a name="line398"></a>  // The two strings must be equivalent except for case (perfect equality is
<a name="line399"></a>  // tested at the head of the function.) Revert to default ASCII-betical string
<a name="line400"></a>  // comparison to stablize the sort.
<a name="line401"></a>  return str1 &lt; str2 ? -1 : 1;
<a name="line402"></a>};
<a name="line403"></a>
<a name="line404"></a>
<a name="line405"></a>/**
<a name="line406"></a> * Regular expression used for determining if a string needs to be encoded.
<a name="line407"></a> * @type {RegExp}
<a name="line408"></a> * @private
<a name="line409"></a> */
<a name="line410"></a>goog.string.encodeUriRegExp_ = /^[a-zA-Z0-9\-_.!~*&#39;()]*$/;
<a name="line411"></a>
<a name="line412"></a>
<a name="line413"></a>/**
<a name="line414"></a> * URL-encodes a string
<a name="line415"></a> * @param {*} str The string to url-encode.
<a name="line416"></a> * @return {string} An encoded copy of {@code str} that is safe for urls.
<a name="line417"></a> *     Note that &#39;#&#39;, &#39;:&#39;, and other characters used to delimit portions
<a name="line418"></a> *     of URLs *will* be encoded.
<a name="line419"></a> */
<a name="line420"></a>goog.string.urlEncode = function(str) {
<a name="line421"></a>  str = String(str);
<a name="line422"></a>  // Checking if the search matches before calling encodeURIComponent avoids an
<a name="line423"></a>  // extra allocation in IE6. This adds about 10us time in FF and a similiar
<a name="line424"></a>  // over head in IE6 for lower working set apps, but for large working set
<a name="line425"></a>  // apps like Gmail, it saves about 70us per call.
<a name="line426"></a>  if (!goog.string.encodeUriRegExp_.test(str)) {
<a name="line427"></a>    return encodeURIComponent(str);
<a name="line428"></a>  }
<a name="line429"></a>  return str;
<a name="line430"></a>};
<a name="line431"></a>
<a name="line432"></a>
<a name="line433"></a>/**
<a name="line434"></a> * URL-decodes the string. We need to specially handle &#39;+&#39;s because
<a name="line435"></a> * the javascript library doesn&#39;t convert them to spaces.
<a name="line436"></a> * @param {string} str The string to url decode.
<a name="line437"></a> * @return {string} The decoded {@code str}.
<a name="line438"></a> */
<a name="line439"></a>goog.string.urlDecode = function(str) {
<a name="line440"></a>  return decodeURIComponent(str.replace(/\+/g, &#39; &#39;));
<a name="line441"></a>};
<a name="line442"></a>
<a name="line443"></a>
<a name="line444"></a>/**
<a name="line445"></a> * Converts \n to &lt;br&gt;s or &lt;br /&gt;s.
<a name="line446"></a> * @param {string} str The string in which to convert newlines.
<a name="line447"></a> * @param {boolean=} opt_xml Whether to use XML compatible tags.
<a name="line448"></a> * @return {string} A copy of {@code str} with converted newlines.
<a name="line449"></a> */
<a name="line450"></a>goog.string.newLineToBr = function(str, opt_xml) {
<a name="line451"></a>  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? &#39;&lt;br /&gt;&#39; : &#39;&lt;br&gt;&#39;);
<a name="line452"></a>};
<a name="line453"></a>
<a name="line454"></a>
<a name="line455"></a>/**
<a name="line456"></a> * Escape double quote &#39;&quot;&#39; characters in addition to &#39;&amp;&#39;, &#39;&lt;&#39;, and &#39;&gt;&#39; so that a
<a name="line457"></a> * string can be included in an HTML tag attribute value within double quotes.
<a name="line458"></a> *
<a name="line459"></a> * It should be noted that &gt; doesn&#39;t need to be escaped for the HTML or XML to
<a name="line460"></a> * be valid, but it has been decided to escape it for consistency with other
<a name="line461"></a> * implementations.
<a name="line462"></a> *
<a name="line463"></a> * NOTE(user):
<a name="line464"></a> * HtmlEscape is often called during the generation of large blocks of HTML.
<a name="line465"></a> * Using statics for the regular expressions and strings is an optimization
<a name="line466"></a> * that can more than half the amount of time IE spends in this function for
<a name="line467"></a> * large apps, since strings and regexes both contribute to GC allocations.
<a name="line468"></a> *
<a name="line469"></a> * Testing for the presence of a character before escaping increases the number
<a name="line470"></a> * of function calls, but actually provides a speed increase for the average
<a name="line471"></a> * case -- since the average case often doesn&#39;t require the escaping of all 4
<a name="line472"></a> * characters and indexOf() is much cheaper than replace().
<a name="line473"></a> * The worst case does suffer slightly from the additional calls, therefore the
<a name="line474"></a> * opt_isLikelyToContainHtmlChars option has been included for situations
<a name="line475"></a> * where all 4 HTML entities are very likely to be present and need escaping.
<a name="line476"></a> *
<a name="line477"></a> * Some benchmarks (times tended to fluctuate +-0.05ms):
<a name="line478"></a> *                                     FireFox                     IE6
<a name="line479"></a> * (no chars / average (mix of cases) / all 4 chars)
<a name="line480"></a> * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
<a name="line481"></a> * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
<a name="line482"></a> * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
<a name="line483"></a> *
<a name="line484"></a> * An additional advantage of checking if replace actually needs to be called
<a name="line485"></a> * is a reduction in the number of object allocations, so as the size of the
<a name="line486"></a> * application grows the difference between the various methods would increase.
<a name="line487"></a> *
<a name="line488"></a> * @param {string} str string to be escaped.
<a name="line489"></a> * @param {boolean=} opt_isLikelyToContainHtmlChars Don&#39;t perform a check to see
<a name="line490"></a> *     if the character needs replacing - use this option if you expect each of
<a name="line491"></a> *     the characters to appear often. Leave false if you expect few html
<a name="line492"></a> *     characters to occur in your strings, such as if you are escaping HTML.
<a name="line493"></a> * @return {string} An escaped copy of {@code str}.
<a name="line494"></a> */
<a name="line495"></a>goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {
<a name="line496"></a>
<a name="line497"></a>  if (opt_isLikelyToContainHtmlChars) {
<a name="line498"></a>    return str.replace(goog.string.amperRe_, &#39;&amp;amp;&#39;)
<a name="line499"></a>          .replace(goog.string.ltRe_, &#39;&amp;lt;&#39;)
<a name="line500"></a>          .replace(goog.string.gtRe_, &#39;&amp;gt;&#39;)
<a name="line501"></a>          .replace(goog.string.quotRe_, &#39;&amp;quot;&#39;);
<a name="line502"></a>
<a name="line503"></a>  } else {
<a name="line504"></a>    // quick test helps in the case when there are no chars to replace, in
<a name="line505"></a>    // worst case this makes barely a difference to the time taken
<a name="line506"></a>    if (!goog.string.allRe_.test(str)) return str;
<a name="line507"></a>
<a name="line508"></a>    // str.indexOf is faster than regex.test in this case
<a name="line509"></a>    if (str.indexOf(&#39;&amp;&#39;) != -1) {
<a name="line510"></a>      str = str.replace(goog.string.amperRe_, &#39;&amp;amp;&#39;);
<a name="line511"></a>    }
<a name="line512"></a>    if (str.indexOf(&#39;&lt;&#39;) != -1) {
<a name="line513"></a>      str = str.replace(goog.string.ltRe_, &#39;&amp;lt;&#39;);
<a name="line514"></a>    }
<a name="line515"></a>    if (str.indexOf(&#39;&gt;&#39;) != -1) {
<a name="line516"></a>      str = str.replace(goog.string.gtRe_, &#39;&amp;gt;&#39;);
<a name="line517"></a>    }
<a name="line518"></a>    if (str.indexOf(&#39;&quot;&#39;) != -1) {
<a name="line519"></a>      str = str.replace(goog.string.quotRe_, &#39;&amp;quot;&#39;);
<a name="line520"></a>    }
<a name="line521"></a>    return str;
<a name="line522"></a>  }
<a name="line523"></a>};
<a name="line524"></a>
<a name="line525"></a>
<a name="line526"></a>/**
<a name="line527"></a> * Regular expression that matches an ampersand, for use in escaping.
<a name="line528"></a> * @type {RegExp}
<a name="line529"></a> * @private
<a name="line530"></a> */
<a name="line531"></a>goog.string.amperRe_ = /&amp;/g;
<a name="line532"></a>
<a name="line533"></a>
<a name="line534"></a>/**
<a name="line535"></a> * Regular expression that matches a less than sign, for use in escaping.
<a name="line536"></a> * @type {RegExp}
<a name="line537"></a> * @private
<a name="line538"></a> */
<a name="line539"></a>goog.string.ltRe_ = /&lt;/g;
<a name="line540"></a>
<a name="line541"></a>
<a name="line542"></a>/**
<a name="line543"></a> * Regular expression that matches a greater than sign, for use in escaping.
<a name="line544"></a> * @type {RegExp}
<a name="line545"></a> * @private
<a name="line546"></a> */
<a name="line547"></a>goog.string.gtRe_ = /&gt;/g;
<a name="line548"></a>
<a name="line549"></a>
<a name="line550"></a>/**
<a name="line551"></a> * Regular expression that matches a double quote, for use in escaping.
<a name="line552"></a> * @type {RegExp}
<a name="line553"></a> * @private
<a name="line554"></a> */
<a name="line555"></a>goog.string.quotRe_ = /\&quot;/g;
<a name="line556"></a>
<a name="line557"></a>
<a name="line558"></a>/**
<a name="line559"></a> * Regular expression that matches any character that needs to be escaped.
<a name="line560"></a> * @type {RegExp}
<a name="line561"></a> * @private
<a name="line562"></a> */
<a name="line563"></a>goog.string.allRe_ = /[&amp;&lt;&gt;\&quot;]/;
<a name="line564"></a>
<a name="line565"></a>
<a name="line566"></a>/**
<a name="line567"></a> * Unescapes an HTML string.
<a name="line568"></a> *
<a name="line569"></a> * @param {string} str The string to unescape.
<a name="line570"></a> * @return {string} An unescaped copy of {@code str}.
<a name="line571"></a> */
<a name="line572"></a>goog.string.unescapeEntities = function(str) {
<a name="line573"></a>  if (goog.string.contains(str, &#39;&amp;&#39;)) {
<a name="line574"></a>    // We are careful not to use a DOM if we do not have one. We use the []
<a name="line575"></a>    // notation so that the JSCompiler will not complain about these objects and
<a name="line576"></a>    // fields in the case where we have no DOM.
<a name="line577"></a>    if (&#39;document&#39; in goog.global) {
<a name="line578"></a>      return goog.string.unescapeEntitiesUsingDom_(str);
<a name="line579"></a>    } else {
<a name="line580"></a>      // Fall back on pure XML entities
<a name="line581"></a>      return goog.string.unescapePureXmlEntities_(str);
<a name="line582"></a>    }
<a name="line583"></a>  }
<a name="line584"></a>  return str;
<a name="line585"></a>};
<a name="line586"></a>
<a name="line587"></a>
<a name="line588"></a>/**
<a name="line589"></a> * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
<a name="line590"></a> * entities. This function is XSS-safe and whitespace-preserving.
<a name="line591"></a> * @private
<a name="line592"></a> * @param {string} str The string to unescape.
<a name="line593"></a> * @return {string} The unescaped {@code str} string.
<a name="line594"></a> */
<a name="line595"></a>goog.string.unescapeEntitiesUsingDom_ = function(str) {
<a name="line596"></a>  var seen = {&#39;&amp;amp;&#39;: &#39;&amp;&#39;, &#39;&amp;lt;&#39;: &#39;&lt;&#39;, &#39;&amp;gt;&#39;: &#39;&gt;&#39;, &#39;&amp;quot;&#39;: &#39;&quot;&#39;};
<a name="line597"></a>  var div = document.createElement(&#39;div&#39;);
<a name="line598"></a>  // Match as many valid entity characters as possible. If the actual entity
<a name="line599"></a>  // happens to be shorter, it will still work as innerHTML will return the
<a name="line600"></a>  // trailing characters unchanged. Since the entity characters do not include
<a name="line601"></a>  // open angle bracket, there is no chance of XSS from the innerHTML use.
<a name="line602"></a>  // Since no whitespace is passed to innerHTML, whitespace is preserved.
<a name="line603"></a>  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
<a name="line604"></a>    // Check for cached entity.
<a name="line605"></a>    var value = seen[s];
<a name="line606"></a>    if (value) {
<a name="line607"></a>      return value;
<a name="line608"></a>    }
<a name="line609"></a>    // Check for numeric entity.
<a name="line610"></a>    if (entity.charAt(0) == &#39;#&#39;) {
<a name="line611"></a>      // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex numbers.
<a name="line612"></a>      var n = Number(&#39;0&#39; + entity.substr(1));
<a name="line613"></a>      if (!isNaN(n)) {
<a name="line614"></a>        value = String.fromCharCode(n);
<a name="line615"></a>      }
<a name="line616"></a>    }
<a name="line617"></a>    // Fall back to innerHTML otherwise.
<a name="line618"></a>    if (!value) {
<a name="line619"></a>      // Append a non-entity character to avoid a bug in Webkit that parses
<a name="line620"></a>      // an invalid entity at the end of innerHTML text as the empty string.
<a name="line621"></a>      div.innerHTML = s + &#39; &#39;;
<a name="line622"></a>      // Then remove the trailing character from the result.
<a name="line623"></a>      value = div.firstChild.nodeValue.slice(0, -1);
<a name="line624"></a>    }
<a name="line625"></a>    // Cache and return.
<a name="line626"></a>    return seen[s] = value;
<a name="line627"></a>  });
<a name="line628"></a>};
<a name="line629"></a>
<a name="line630"></a>
<a name="line631"></a>/**
<a name="line632"></a> * Unescapes XML entities.
<a name="line633"></a> * @private
<a name="line634"></a> * @param {string} str The string to unescape.
<a name="line635"></a> * @return {string} An unescaped copy of {@code str}.
<a name="line636"></a> */
<a name="line637"></a>goog.string.unescapePureXmlEntities_ = function(str) {
<a name="line638"></a>  return str.replace(/&amp;([^;]+);/g, function(s, entity) {
<a name="line639"></a>    switch (entity) {
<a name="line640"></a>      case &#39;amp&#39;:
<a name="line641"></a>        return &#39;&amp;&#39;;
<a name="line642"></a>      case &#39;lt&#39;:
<a name="line643"></a>        return &#39;&lt;&#39;;
<a name="line644"></a>      case &#39;gt&#39;:
<a name="line645"></a>        return &#39;&gt;&#39;;
<a name="line646"></a>      case &#39;quot&#39;:
<a name="line647"></a>        return &#39;&quot;&#39;;
<a name="line648"></a>      default:
<a name="line649"></a>        if (entity.charAt(0) == &#39;#&#39;) {
<a name="line650"></a>          // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex.
<a name="line651"></a>          var n = Number(&#39;0&#39; + entity.substr(1));
<a name="line652"></a>          if (!isNaN(n)) {
<a name="line653"></a>            return String.fromCharCode(n);
<a name="line654"></a>          }
<a name="line655"></a>        }
<a name="line656"></a>        // For invalid entities we just return the entity
<a name="line657"></a>        return s;
<a name="line658"></a>    }
<a name="line659"></a>  });
<a name="line660"></a>};
<a name="line661"></a>
<a name="line662"></a>
<a name="line663"></a>/**
<a name="line664"></a> * Regular expression that matches an HTML entity.
<a name="line665"></a> * See also HTML5: Tokenization / Tokenizing character references.
<a name="line666"></a> * @private
<a name="line667"></a> * @type {!RegExp}
<a name="line668"></a> */
<a name="line669"></a>goog.string.HTML_ENTITY_PATTERN_ = /&amp;([^;\s&lt;&amp;]+);?/g;
<a name="line670"></a>
<a name="line671"></a>
<a name="line672"></a>/**
<a name="line673"></a> * Do escaping of whitespace to preserve spatial formatting. We use character
<a name="line674"></a> * entity #160 to make it safer for xml.
<a name="line675"></a> * @param {string} str The string in which to escape whitespace.
<a name="line676"></a> * @param {boolean=} opt_xml Whether to use XML compatible tags.
<a name="line677"></a> * @return {string} An escaped copy of {@code str}.
<a name="line678"></a> */
<a name="line679"></a>goog.string.whitespaceEscape = function(str, opt_xml) {
<a name="line680"></a>  return goog.string.newLineToBr(str.replace(/  /g, &#39; &amp;#160;&#39;), opt_xml);
<a name="line681"></a>};
<a name="line682"></a>
<a name="line683"></a>
<a name="line684"></a>/**
<a name="line685"></a> * Strip quote characters around a string.  The second argument is a string of
<a name="line686"></a> * characters to treat as quotes.  This can be a single character or a string of
<a name="line687"></a> * multiple character and in that case each of those are treated as possible
<a name="line688"></a> * quote characters. For example:
<a name="line689"></a> *
<a name="line690"></a> * &lt;pre&gt;
<a name="line691"></a> * goog.string.stripQuotes(&#39;&quot;abc&quot;&#39;, &#39;&quot;`&#39;) --&gt; &#39;abc&#39;
<a name="line692"></a> * goog.string.stripQuotes(&#39;`abc`&#39;, &#39;&quot;`&#39;) --&gt; &#39;abc&#39;
<a name="line693"></a> * &lt;/pre&gt;
<a name="line694"></a> *
<a name="line695"></a> * @param {string} str The string to strip.
<a name="line696"></a> * @param {string} quoteChars The quote characters to strip.
<a name="line697"></a> * @return {string} A copy of {@code str} without the quotes.
<a name="line698"></a> */
<a name="line699"></a>goog.string.stripQuotes = function(str, quoteChars) {
<a name="line700"></a>  var length = quoteChars.length;
<a name="line701"></a>  for (var i = 0; i &lt; length; i++) {
<a name="line702"></a>    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
<a name="line703"></a>    if (str.charAt(0) == quoteChar &amp;&amp; str.charAt(str.length - 1) == quoteChar) {
<a name="line704"></a>      return str.substring(1, str.length - 1);
<a name="line705"></a>    }
<a name="line706"></a>  }
<a name="line707"></a>  return str;
<a name="line708"></a>};
<a name="line709"></a>
<a name="line710"></a>
<a name="line711"></a>/**
<a name="line712"></a> * Truncates a string to a certain length and adds &#39;...&#39; if necessary.  The
<a name="line713"></a> * length also accounts for the ellipsis, so a maximum length of 10 and a string
<a name="line714"></a> * &#39;Hello World!&#39; produces &#39;Hello W...&#39;.
<a name="line715"></a> * @param {string} str The string to truncate.
<a name="line716"></a> * @param {number} chars Max number of characters.
<a name="line717"></a> * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
<a name="line718"></a> *     characters from being cut off in the middle.
<a name="line719"></a> * @return {string} The truncated {@code str} string.
<a name="line720"></a> */
<a name="line721"></a>goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
<a name="line722"></a>  if (opt_protectEscapedCharacters) {
<a name="line723"></a>    str = goog.string.unescapeEntities(str);
<a name="line724"></a>  }
<a name="line725"></a>
<a name="line726"></a>  if (str.length &gt; chars) {
<a name="line727"></a>    str = str.substring(0, chars - 3) + &#39;...&#39;;
<a name="line728"></a>  }
<a name="line729"></a>
<a name="line730"></a>  if (opt_protectEscapedCharacters) {
<a name="line731"></a>    str = goog.string.htmlEscape(str);
<a name="line732"></a>  }
<a name="line733"></a>
<a name="line734"></a>  return str;
<a name="line735"></a>};
<a name="line736"></a>
<a name="line737"></a>
<a name="line738"></a>/**
<a name="line739"></a> * Truncate a string in the middle, adding &quot;...&quot; if necessary,
<a name="line740"></a> * and favoring the beginning of the string.
<a name="line741"></a> * @param {string} str The string to truncate the middle of.
<a name="line742"></a> * @param {number} chars Max number of characters.
<a name="line743"></a> * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
<a name="line744"></a> *     characters from being cutoff in the middle.
<a name="line745"></a> * @param {number=} opt_trailingChars Optional number of trailing characters to
<a name="line746"></a> *     leave at the end of the string, instead of truncating as close to the
<a name="line747"></a> *     middle as possible.
<a name="line748"></a> * @return {string} A truncated copy of {@code str}.
<a name="line749"></a> */
<a name="line750"></a>goog.string.truncateMiddle = function(str, chars,
<a name="line751"></a>    opt_protectEscapedCharacters, opt_trailingChars) {
<a name="line752"></a>  if (opt_protectEscapedCharacters) {
<a name="line753"></a>    str = goog.string.unescapeEntities(str);
<a name="line754"></a>  }
<a name="line755"></a>
<a name="line756"></a>  if (opt_trailingChars &amp;&amp; str.length &gt; chars) {
<a name="line757"></a>    if (opt_trailingChars &gt; chars) {
<a name="line758"></a>      opt_trailingChars = chars;
<a name="line759"></a>    }
<a name="line760"></a>    var endPoint = str.length - opt_trailingChars;
<a name="line761"></a>    var startPoint = chars - opt_trailingChars;
<a name="line762"></a>    str = str.substring(0, startPoint) + &#39;...&#39; + str.substring(endPoint);
<a name="line763"></a>  } else if (str.length &gt; chars) {
<a name="line764"></a>    // Favor the beginning of the string:
<a name="line765"></a>    var half = Math.floor(chars / 2);
<a name="line766"></a>    var endPos = str.length - half;
<a name="line767"></a>    half += chars % 2;
<a name="line768"></a>    str = str.substring(0, half) + &#39;...&#39; + str.substring(endPos);
<a name="line769"></a>  }
<a name="line770"></a>
<a name="line771"></a>  if (opt_protectEscapedCharacters) {
<a name="line772"></a>    str = goog.string.htmlEscape(str);
<a name="line773"></a>  }
<a name="line774"></a>
<a name="line775"></a>  return str;
<a name="line776"></a>};
<a name="line777"></a>
<a name="line778"></a>
<a name="line779"></a>/**
<a name="line780"></a> * Special chars that need to be escaped for goog.string.quote.
<a name="line781"></a> * @private
<a name="line782"></a> * @type {Object}
<a name="line783"></a> */
<a name="line784"></a>goog.string.specialEscapeChars_ = {
<a name="line785"></a>  &#39;\0&#39;: &#39;\\0&#39;,
<a name="line786"></a>  &#39;\b&#39;: &#39;\\b&#39;,
<a name="line787"></a>  &#39;\f&#39;: &#39;\\f&#39;,
<a name="line788"></a>  &#39;\n&#39;: &#39;\\n&#39;,
<a name="line789"></a>  &#39;\r&#39;: &#39;\\r&#39;,
<a name="line790"></a>  &#39;\t&#39;: &#39;\\t&#39;,
<a name="line791"></a>  &#39;\x0B&#39;: &#39;\\x0B&#39;, // &#39;\v&#39; is not supported in JScript
<a name="line792"></a>  &#39;&quot;&#39;: &#39;\\&quot;&#39;,
<a name="line793"></a>  &#39;\\&#39;: &#39;\\\\&#39;
<a name="line794"></a>};
<a name="line795"></a>
<a name="line796"></a>
<a name="line797"></a>/**
<a name="line798"></a> * Character mappings used internally for goog.string.escapeChar.
<a name="line799"></a> * @private
<a name="line800"></a> * @type {Object}
<a name="line801"></a> */
<a name="line802"></a>goog.string.jsEscapeCache_ = {
<a name="line803"></a>  &#39;\&#39;&#39;: &#39;\\\&#39;&#39;
<a name="line804"></a>};
<a name="line805"></a>
<a name="line806"></a>
<a name="line807"></a>/**
<a name="line808"></a> * Encloses a string in double quotes and escapes characters so that the
<a name="line809"></a> * string is a valid JS string.
<a name="line810"></a> * @param {string} s The string to quote.
<a name="line811"></a> * @return {string} A copy of {@code s} surrounded by double quotes.
<a name="line812"></a> */
<a name="line813"></a>goog.string.quote = function(s) {
<a name="line814"></a>  s = String(s);
<a name="line815"></a>  if (s.quote) {
<a name="line816"></a>    return s.quote();
<a name="line817"></a>  } else {
<a name="line818"></a>    var sb = [&#39;&quot;&#39;];
<a name="line819"></a>    for (var i = 0; i &lt; s.length; i++) {
<a name="line820"></a>      var ch = s.charAt(i);
<a name="line821"></a>      var cc = ch.charCodeAt(0);
<a name="line822"></a>      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
<a name="line823"></a>          ((cc &gt; 31 &amp;&amp; cc &lt; 127) ? ch : goog.string.escapeChar(ch));
<a name="line824"></a>    }
<a name="line825"></a>    sb.push(&#39;&quot;&#39;);
<a name="line826"></a>    return sb.join(&#39;&#39;);
<a name="line827"></a>  }
<a name="line828"></a>};
<a name="line829"></a>
<a name="line830"></a>
<a name="line831"></a>/**
<a name="line832"></a> * Takes a string and returns the escaped string for that character.
<a name="line833"></a> * @param {string} str The string to escape.
<a name="line834"></a> * @return {string} An escaped string representing {@code str}.
<a name="line835"></a> */
<a name="line836"></a>goog.string.escapeString = function(str) {
<a name="line837"></a>  var sb = [];
<a name="line838"></a>  for (var i = 0; i &lt; str.length; i++) {
<a name="line839"></a>    sb[i] = goog.string.escapeChar(str.charAt(i));
<a name="line840"></a>  }
<a name="line841"></a>  return sb.join(&#39;&#39;);
<a name="line842"></a>};
<a name="line843"></a>
<a name="line844"></a>
<a name="line845"></a>/**
<a name="line846"></a> * Takes a character and returns the escaped string for that character. For
<a name="line847"></a> * example escapeChar(String.fromCharCode(15)) -&gt; &quot;\\x0E&quot;.
<a name="line848"></a> * @param {string} c The character to escape.
<a name="line849"></a> * @return {string} An escaped string representing {@code c}.
<a name="line850"></a> */
<a name="line851"></a>goog.string.escapeChar = function(c) {
<a name="line852"></a>  if (c in goog.string.jsEscapeCache_) {
<a name="line853"></a>    return goog.string.jsEscapeCache_[c];
<a name="line854"></a>  }
<a name="line855"></a>
<a name="line856"></a>  if (c in goog.string.specialEscapeChars_) {
<a name="line857"></a>    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
<a name="line858"></a>  }
<a name="line859"></a>
<a name="line860"></a>  var rv = c;
<a name="line861"></a>  var cc = c.charCodeAt(0);
<a name="line862"></a>  if (cc &gt; 31 &amp;&amp; cc &lt; 127) {
<a name="line863"></a>    rv = c;
<a name="line864"></a>  } else {
<a name="line865"></a>    // tab is 9 but handled above
<a name="line866"></a>    if (cc &lt; 256) {
<a name="line867"></a>      rv = &#39;\\x&#39;;
<a name="line868"></a>      if (cc &lt; 16 || cc &gt; 256) {
<a name="line869"></a>        rv += &#39;0&#39;;
<a name="line870"></a>      }
<a name="line871"></a>    } else {
<a name="line872"></a>      rv = &#39;\\u&#39;;
<a name="line873"></a>      if (cc &lt; 4096) { // \u1000
<a name="line874"></a>        rv += &#39;0&#39;;
<a name="line875"></a>      }
<a name="line876"></a>    }
<a name="line877"></a>    rv += cc.toString(16).toUpperCase();
<a name="line878"></a>  }
<a name="line879"></a>
<a name="line880"></a>  return goog.string.jsEscapeCache_[c] = rv;
<a name="line881"></a>};
<a name="line882"></a>
<a name="line883"></a>
<a name="line884"></a>/**
<a name="line885"></a> * Takes a string and creates a map (Object) in which the keys are the
<a name="line886"></a> * characters in the string. The value for the key is set to true. You can
<a name="line887"></a> * then use goog.object.map or goog.array.map to change the values.
<a name="line888"></a> * @param {string} s The string to build the map from.
<a name="line889"></a> * @return {Object} The map of characters used.
<a name="line890"></a> */
<a name="line891"></a>// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
<a name="line892"></a>//            we want a dependency on goog.array in goog.string?
<a name="line893"></a>goog.string.toMap = function(s) {
<a name="line894"></a>  var rv = {};
<a name="line895"></a>  for (var i = 0; i &lt; s.length; i++) {
<a name="line896"></a>    rv[s.charAt(i)] = true;
<a name="line897"></a>  }
<a name="line898"></a>  return rv;
<a name="line899"></a>};
<a name="line900"></a>
<a name="line901"></a>
<a name="line902"></a>/**
<a name="line903"></a> * Checks whether a string contains a given character.
<a name="line904"></a> * @param {string} s The string to test.
<a name="line905"></a> * @param {string} ss The substring to test for.
<a name="line906"></a> * @return {boolean} True if {@code s} contains {@code ss}.
<a name="line907"></a> */
<a name="line908"></a>goog.string.contains = function(s, ss) {
<a name="line909"></a>  return s.indexOf(ss) != -1;
<a name="line910"></a>};
<a name="line911"></a>
<a name="line912"></a>
<a name="line913"></a>/**
<a name="line914"></a> * Returns the non-overlapping occurrences of ss in s.
<a name="line915"></a> * If either s or ss evalutes to false, then returns zero.
<a name="line916"></a> * @param {string} s The string to look in.
<a name="line917"></a> * @param {string} ss The string to look for.
<a name="line918"></a> * @return {number} Number of occurrences of ss in s.
<a name="line919"></a> */
<a name="line920"></a>goog.string.countOf = function(s, ss) {
<a name="line921"></a>  return s &amp;&amp; ss ? s.split(ss).length - 1 : 0;
<a name="line922"></a>};
<a name="line923"></a>
<a name="line924"></a>
<a name="line925"></a>/**
<a name="line926"></a> * Removes a substring of a specified length at a specific
<a name="line927"></a> * index in a string.
<a name="line928"></a> * @param {string} s The base string from which to remove.
<a name="line929"></a> * @param {number} index The index at which to remove the substring.
<a name="line930"></a> * @param {number} stringLength The length of the substring to remove.
<a name="line931"></a> * @return {string} A copy of {@code s} with the substring removed or the full
<a name="line932"></a> *     string if nothing is removed or the input is invalid.
<a name="line933"></a> */
<a name="line934"></a>goog.string.removeAt = function(s, index, stringLength) {
<a name="line935"></a>  var resultStr = s;
<a name="line936"></a>  // If the index is greater or equal to 0 then remove substring
<a name="line937"></a>  if (index &gt;= 0 &amp;&amp; index &lt; s.length &amp;&amp; stringLength &gt; 0) {
<a name="line938"></a>    resultStr = s.substr(0, index) +
<a name="line939"></a>        s.substr(index + stringLength, s.length - index - stringLength);
<a name="line940"></a>  }
<a name="line941"></a>  return resultStr;
<a name="line942"></a>};
<a name="line943"></a>
<a name="line944"></a>
<a name="line945"></a>/**
<a name="line946"></a> *  Removes the first occurrence of a substring from a string.
<a name="line947"></a> *  @param {string} s The base string from which to remove.
<a name="line948"></a> *  @param {string} ss The string to remove.
<a name="line949"></a> *  @return {string} A copy of {@code s} with {@code ss} removed or the full
<a name="line950"></a> *      string if nothing is removed.
<a name="line951"></a> */
<a name="line952"></a>goog.string.remove = function(s, ss) {
<a name="line953"></a>  var re = new RegExp(goog.string.regExpEscape(ss), &#39;&#39;);
<a name="line954"></a>  return s.replace(re, &#39;&#39;);
<a name="line955"></a>};
<a name="line956"></a>
<a name="line957"></a>
<a name="line958"></a>/**
<a name="line959"></a> *  Removes all occurrences of a substring from a string.
<a name="line960"></a> *  @param {string} s The base string from which to remove.
<a name="line961"></a> *  @param {string} ss The string to remove.
<a name="line962"></a> *  @return {string} A copy of {@code s} with {@code ss} removed or the full
<a name="line963"></a> *      string if nothing is removed.
<a name="line964"></a> */
<a name="line965"></a>goog.string.removeAll = function(s, ss) {
<a name="line966"></a>  var re = new RegExp(goog.string.regExpEscape(ss), &#39;g&#39;);
<a name="line967"></a>  return s.replace(re, &#39;&#39;);
<a name="line968"></a>};
<a name="line969"></a>
<a name="line970"></a>
<a name="line971"></a>/**
<a name="line972"></a> * Escapes characters in the string that are not safe to use in a RegExp.
<a name="line973"></a> * @param {*} s The string to escape. If not a string, it will be casted
<a name="line974"></a> *     to one.
<a name="line975"></a> * @return {string} A RegExp safe, escaped copy of {@code s}.
<a name="line976"></a> */
<a name="line977"></a>goog.string.regExpEscape = function(s) {
<a name="line978"></a>  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, &#39;\\$1&#39;).
<a name="line979"></a>      replace(/\x08/g, &#39;\\x08&#39;);
<a name="line980"></a>};
<a name="line981"></a>
<a name="line982"></a>
<a name="line983"></a>/**
<a name="line984"></a> * Repeats a string n times.
<a name="line985"></a> * @param {string} string The string to repeat.
<a name="line986"></a> * @param {number} length The number of times to repeat.
<a name="line987"></a> * @return {string} A string containing {@code length} repetitions of
<a name="line988"></a> *     {@code string}.
<a name="line989"></a> */
<a name="line990"></a>goog.string.repeat = function(string, length) {
<a name="line991"></a>  return new Array(length + 1).join(string);
<a name="line992"></a>};
<a name="line993"></a>
<a name="line994"></a>
<a name="line995"></a>/**
<a name="line996"></a> * Pads number to given length and optionally rounds it to a given precision.
<a name="line997"></a> * For example:
<a name="line998"></a> * &lt;pre&gt;padNumber(1.25, 2, 3) -&gt; &#39;01.250&#39;
<a name="line999"></a> * padNumber(1.25, 2) -&gt; &#39;01.25&#39;
<a name="line1000"></a> * padNumber(1.25, 2, 1) -&gt; &#39;01.3&#39;
<a name="line1001"></a> * padNumber(1.25, 0) -&gt; &#39;1.25&#39;&lt;/pre&gt;
<a name="line1002"></a> *
<a name="line1003"></a> * @param {number} num The number to pad.
<a name="line1004"></a> * @param {number} length The desired length.
<a name="line1005"></a> * @param {number=} opt_precision The desired precision.
<a name="line1006"></a> * @return {string} {@code num} as a string with the given options.
<a name="line1007"></a> */
<a name="line1008"></a>goog.string.padNumber = function(num, length, opt_precision) {
<a name="line1009"></a>  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
<a name="line1010"></a>  var index = s.indexOf(&#39;.&#39;);
<a name="line1011"></a>  if (index == -1) {
<a name="line1012"></a>    index = s.length;
<a name="line1013"></a>  }
<a name="line1014"></a>  return goog.string.repeat(&#39;0&#39;, Math.max(0, length - index)) + s;
<a name="line1015"></a>};
<a name="line1016"></a>
<a name="line1017"></a>
<a name="line1018"></a>/**
<a name="line1019"></a> * Returns a string representation of the given object, with
<a name="line1020"></a> * null and undefined being returned as the empty string.
<a name="line1021"></a> *
<a name="line1022"></a> * @param {*} obj The object to convert.
<a name="line1023"></a> * @return {string} A string representation of the {@code obj}.
<a name="line1024"></a> */
<a name="line1025"></a>goog.string.makeSafe = function(obj) {
<a name="line1026"></a>  return obj == null ? &#39;&#39; : String(obj);
<a name="line1027"></a>};
<a name="line1028"></a>
<a name="line1029"></a>
<a name="line1030"></a>/**
<a name="line1031"></a> * Concatenates string expressions. This is useful
<a name="line1032"></a> * since some browsers are very inefficient when it comes to using plus to
<a name="line1033"></a> * concat strings. Be careful when using null and undefined here since
<a name="line1034"></a> * these will not be included in the result. If you need to represent these
<a name="line1035"></a> * be sure to cast the argument to a String first.
<a name="line1036"></a> * For example:
<a name="line1037"></a> * &lt;pre&gt;buildString(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) -&gt; &#39;abcd&#39;
<a name="line1038"></a> * buildString(null, undefined) -&gt; &#39;&#39;
<a name="line1039"></a> * &lt;/pre&gt;
<a name="line1040"></a> * @param {...*} var_args A list of strings to concatenate. If not a string,
<a name="line1041"></a> *     it will be casted to one.
<a name="line1042"></a> * @return {string} The concatenation of {@code var_args}.
<a name="line1043"></a> */
<a name="line1044"></a>goog.string.buildString = function(var_args) {
<a name="line1045"></a>  return Array.prototype.join.call(arguments, &#39;&#39;);
<a name="line1046"></a>};
<a name="line1047"></a>
<a name="line1048"></a>
<a name="line1049"></a>/**
<a name="line1050"></a> * Returns a string with at least 64-bits of randomness.
<a name="line1051"></a> *
<a name="line1052"></a> * Doesn&#39;t trust Javascript&#39;s random function entirely. Uses a combination of
<a name="line1053"></a> * random and current timestamp, and then encodes the string in base-36 to
<a name="line1054"></a> * make it shorter.
<a name="line1055"></a> *
<a name="line1056"></a> * @return {string} A random string, e.g. sn1s7vb4gcic.
<a name="line1057"></a> */
<a name="line1058"></a>goog.string.getRandomString = function() {
<a name="line1059"></a>  var x = 2147483648;
<a name="line1060"></a>  return Math.floor(Math.random() * x).toString(36) +
<a name="line1061"></a>         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
<a name="line1062"></a>};
<a name="line1063"></a>
<a name="line1064"></a>
<a name="line1065"></a>/**
<a name="line1066"></a> * Compares two version numbers.
<a name="line1067"></a> *
<a name="line1068"></a> * @param {string|number} version1 Version of first item.
<a name="line1069"></a> * @param {string|number} version2 Version of second item.
<a name="line1070"></a> *
<a name="line1071"></a> * @return {number}  1 if {@code version1} is higher.
<a name="line1072"></a> *                   0 if arguments are equal.
<a name="line1073"></a> *                  -1 if {@code version2} is higher.
<a name="line1074"></a> */
<a name="line1075"></a>goog.string.compareVersions = function(version1, version2) {
<a name="line1076"></a>  var order = 0;
<a name="line1077"></a>  // Trim leading and trailing whitespace and split the versions into
<a name="line1078"></a>  // subversions.
<a name="line1079"></a>  var v1Subs = goog.string.trim(String(version1)).split(&#39;.&#39;);
<a name="line1080"></a>  var v2Subs = goog.string.trim(String(version2)).split(&#39;.&#39;);
<a name="line1081"></a>  var subCount = Math.max(v1Subs.length, v2Subs.length);
<a name="line1082"></a>
<a name="line1083"></a>  // Iterate over the subversions, as long as they appear to be equivalent.
<a name="line1084"></a>  for (var subIdx = 0; order == 0 &amp;&amp; subIdx &lt; subCount; subIdx++) {
<a name="line1085"></a>    var v1Sub = v1Subs[subIdx] || &#39;&#39;;
<a name="line1086"></a>    var v2Sub = v2Subs[subIdx] || &#39;&#39;;
<a name="line1087"></a>
<a name="line1088"></a>    // Split the subversions into pairs of numbers and qualifiers (like &#39;b&#39;).
<a name="line1089"></a>    // Two different RegExp objects are needed because they are both using
<a name="line1090"></a>    // the &#39;g&#39; flag.
<a name="line1091"></a>    var v1CompParser = new RegExp(&#39;(\\d*)(\\D*)&#39;, &#39;g&#39;);
<a name="line1092"></a>    var v2CompParser = new RegExp(&#39;(\\d*)(\\D*)&#39;, &#39;g&#39;);
<a name="line1093"></a>    do {
<a name="line1094"></a>      var v1Comp = v1CompParser.exec(v1Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;];
<a name="line1095"></a>      var v2Comp = v2CompParser.exec(v2Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;];
<a name="line1096"></a>      // Break if there are no more matches.
<a name="line1097"></a>      if (v1Comp[0].length == 0 &amp;&amp; v2Comp[0].length == 0) {
<a name="line1098"></a>        break;
<a name="line1099"></a>      }
<a name="line1100"></a>
<a name="line1101"></a>      // Parse the numeric part of the subversion. A missing number is
<a name="line1102"></a>      // equivalent to 0.
<a name="line1103"></a>      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
<a name="line1104"></a>      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
<a name="line1105"></a>
<a name="line1106"></a>      // Compare the subversion components. The number has the highest
<a name="line1107"></a>      // precedence. Next, if the numbers are equal, a subversion without any
<a name="line1108"></a>      // qualifier is always higher than a subversion with any qualifier. Next,
<a name="line1109"></a>      // the qualifiers are compared as strings.
<a name="line1110"></a>      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
<a name="line1111"></a>          goog.string.compareElements_(v1Comp[2].length == 0,
<a name="line1112"></a>              v2Comp[2].length == 0) ||
<a name="line1113"></a>          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
<a name="line1114"></a>      // Stop as soon as an inequality is discovered.
<a name="line1115"></a>    } while (order == 0);
<a name="line1116"></a>  }
<a name="line1117"></a>
<a name="line1118"></a>  return order;
<a name="line1119"></a>};
<a name="line1120"></a>
<a name="line1121"></a>
<a name="line1122"></a>/**
<a name="line1123"></a> * Compares elements of a version number.
<a name="line1124"></a> *
<a name="line1125"></a> * @param {string|number|boolean} left An element from a version number.
<a name="line1126"></a> * @param {string|number|boolean} right An element from a version number.
<a name="line1127"></a> *
<a name="line1128"></a> * @return {number}  1 if {@code left} is higher.
<a name="line1129"></a> *                   0 if arguments are equal.
<a name="line1130"></a> *                  -1 if {@code right} is higher.
<a name="line1131"></a> * @private
<a name="line1132"></a> */
<a name="line1133"></a>goog.string.compareElements_ = function(left, right) {
<a name="line1134"></a>  if (left &lt; right) {
<a name="line1135"></a>    return -1;
<a name="line1136"></a>  } else if (left &gt; right) {
<a name="line1137"></a>    return 1;
<a name="line1138"></a>  }
<a name="line1139"></a>  return 0;
<a name="line1140"></a>};
<a name="line1141"></a>
<a name="line1142"></a>
<a name="line1143"></a>/**
<a name="line1144"></a> * Maximum value of #goog.string.hashCode, exclusive. 2^32.
<a name="line1145"></a> * @type {number}
<a name="line1146"></a> * @private
<a name="line1147"></a> */
<a name="line1148"></a>goog.string.HASHCODE_MAX_ = 0x100000000;
<a name="line1149"></a>
<a name="line1150"></a>
<a name="line1151"></a>/**
<a name="line1152"></a> * String hash function similar to java.lang.String.hashCode().
<a name="line1153"></a> * The hash code for a string is computed as
<a name="line1154"></a> * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
<a name="line1155"></a> * where s[i] is the ith character of the string and n is the length of
<a name="line1156"></a> * the string. We mod the result to make it between 0 (inclusive) and 2^32
<a name="line1157"></a> * (exclusive).
<a name="line1158"></a> * @param {string} str A string.
<a name="line1159"></a> * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
<a name="line1160"></a> *  (exclusive). The empty string returns 0.
<a name="line1161"></a> */
<a name="line1162"></a>goog.string.hashCode = function(str) {
<a name="line1163"></a>  var result = 0;
<a name="line1164"></a>  for (var i = 0; i &lt; str.length; ++i) {
<a name="line1165"></a>    result = 31 * result + str.charCodeAt(i);
<a name="line1166"></a>    // Normalize to 4 byte range, 0 ... 2^32.
<a name="line1167"></a>    result %= goog.string.HASHCODE_MAX_;
<a name="line1168"></a>  }
<a name="line1169"></a>  return result;
<a name="line1170"></a>};
<a name="line1171"></a>
<a name="line1172"></a>
<a name="line1173"></a>/**
<a name="line1174"></a> * The most recent unique ID. |0 is equivalent to Math.floor in this case.
<a name="line1175"></a> * @type {number}
<a name="line1176"></a> * @private
<a name="line1177"></a> */
<a name="line1178"></a>goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;
<a name="line1179"></a>
<a name="line1180"></a>
<a name="line1181"></a>/**
<a name="line1182"></a> * Generates and returns a string which is unique in the current document.
<a name="line1183"></a> * This is useful, for example, to create unique IDs for DOM elements.
<a name="line1184"></a> * @return {string} A unique id.
<a name="line1185"></a> */
<a name="line1186"></a>goog.string.createUniqueString = function() {
<a name="line1187"></a>  return &#39;goog_&#39; + goog.string.uniqueStringCounter_++;
<a name="line1188"></a>};
<a name="line1189"></a>
<a name="line1190"></a>
<a name="line1191"></a>/**
<a name="line1192"></a> * Converts the supplied string to a number, which may be Ininity or NaN.
<a name="line1193"></a> * This function strips whitespace: (toNumber(&#39; 123&#39;) === 123)
<a name="line1194"></a> * This function accepts scientific notation: (toNumber(&#39;1e1&#39;) === 10)
<a name="line1195"></a> *
<a name="line1196"></a> * This is better than Javascript&#39;s built-in conversions because, sadly:
<a name="line1197"></a> *     (Number(&#39; &#39;) === 0) and (parseFloat(&#39;123a&#39;) === 123)
<a name="line1198"></a> *
<a name="line1199"></a> * @param {string} str The string to convert.
<a name="line1200"></a> * @return {number} The number the supplied string represents, or NaN.
<a name="line1201"></a> */
<a name="line1202"></a>goog.string.toNumber = function(str) {
<a name="line1203"></a>  var num = Number(str);
<a name="line1204"></a>  if (num == 0 &amp;&amp; goog.string.isEmpty(str)) {
<a name="line1205"></a>    return NaN;
<a name="line1206"></a>  }
<a name="line1207"></a>  return num;
<a name="line1208"></a>};
<a name="line1209"></a>
<a name="line1210"></a>
<a name="line1211"></a>/**
<a name="line1212"></a> * A memoized cache for goog.string.toCamelCase.
<a name="line1213"></a> * @type {Object.&lt;string&gt;}
<a name="line1214"></a> * @private
<a name="line1215"></a> */
<a name="line1216"></a>goog.string.toCamelCaseCache_ = {};
<a name="line1217"></a>
<a name="line1218"></a>
<a name="line1219"></a>/**
<a name="line1220"></a> * Converts a string from selector-case to camelCase (e.g. from
<a name="line1221"></a> * &quot;multi-part-string&quot; to &quot;multiPartString&quot;), useful for converting
<a name="line1222"></a> * CSS selectors and HTML dataset keys to their equivalent JS properties.
<a name="line1223"></a> * @param {string} str The string in selector-case form.
<a name="line1224"></a> * @return {string} The string in camelCase form.
<a name="line1225"></a> */
<a name="line1226"></a>goog.string.toCamelCase = function(str) {
<a name="line1227"></a>  return goog.string.toCamelCaseCache_[str] ||
<a name="line1228"></a>      (goog.string.toCamelCaseCache_[str] =
<a name="line1229"></a>          String(str).replace(/\-([a-z])/g, function(all, match) {
<a name="line1230"></a>            return match.toUpperCase();
<a name="line1231"></a>          }));
<a name="line1232"></a>};
<a name="line1233"></a>
<a name="line1234"></a>
<a name="line1235"></a>/**
<a name="line1236"></a> * A memoized cache for goog.string.toSelectorCase.
<a name="line1237"></a> * @type {Object.&lt;string&gt;}
<a name="line1238"></a> * @private
<a name="line1239"></a> */
<a name="line1240"></a>goog.string.toSelectorCaseCache_ = {};
<a name="line1241"></a>
<a name="line1242"></a>
<a name="line1243"></a>/**
<a name="line1244"></a> * Converts a string from camelCase to selector-case (e.g. from
<a name="line1245"></a> * &quot;multiPartString&quot; to &quot;multi-part-string&quot;), useful for converting JS
<a name="line1246"></a> * style and dataset properties to equivalent CSS selectors and HTML keys.
<a name="line1247"></a> * @param {string} str The string in camelCase form.
<a name="line1248"></a> * @return {string} The string in selector-case form.
<a name="line1249"></a> */
<a name="line1250"></a>goog.string.toSelectorCase = function(str) {
<a name="line1251"></a>  return goog.string.toSelectorCaseCache_[str] ||
<a name="line1252"></a>      (goog.string.toSelectorCaseCache_[str] =
<a name="line1253"></a>          String(str).replace(/([A-Z])/g, &#39;-$1&#39;).toLowerCase());
<a name="line1254"></a>};
</pre>


</body>
</html>
