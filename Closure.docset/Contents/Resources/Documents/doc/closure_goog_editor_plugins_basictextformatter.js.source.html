<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>basictextformatter.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="closure_goog_editor_plugins_basictextformatter.js.html">basictextformatter.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2006 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Functions to style text.
<a name="line17"></a> *
<a name="line18"></a> */
<a name="line19"></a>
<a name="line20"></a>goog.provide(&#39;goog.editor.plugins.BasicTextFormatter&#39;);
<a name="line21"></a>goog.provide(&#39;goog.editor.plugins.BasicTextFormatter.COMMAND&#39;);
<a name="line22"></a>
<a name="line23"></a>goog.require(&#39;goog.array&#39;);
<a name="line24"></a>goog.require(&#39;goog.debug.Logger&#39;);
<a name="line25"></a>goog.require(&#39;goog.dom&#39;);
<a name="line26"></a>goog.require(&#39;goog.dom.NodeType&#39;);
<a name="line27"></a>goog.require(&#39;goog.dom.TagName&#39;);
<a name="line28"></a>goog.require(&#39;goog.editor.BrowserFeature&#39;);
<a name="line29"></a>goog.require(&#39;goog.editor.Link&#39;);
<a name="line30"></a>goog.require(&#39;goog.editor.Plugin&#39;);
<a name="line31"></a>goog.require(&#39;goog.editor.node&#39;);
<a name="line32"></a>goog.require(&#39;goog.editor.range&#39;);
<a name="line33"></a>goog.require(&#39;goog.iter&#39;);
<a name="line34"></a>goog.require(&#39;goog.object&#39;);
<a name="line35"></a>goog.require(&#39;goog.string&#39;);
<a name="line36"></a>goog.require(&#39;goog.string.Unicode&#39;);
<a name="line37"></a>goog.require(&#39;goog.style&#39;);
<a name="line38"></a>goog.require(&#39;goog.ui.editor.messages&#39;);
<a name="line39"></a>goog.require(&#39;goog.userAgent&#39;);
<a name="line40"></a>
<a name="line41"></a>
<a name="line42"></a>
<a name="line43"></a>/**
<a name="line44"></a> * Functions to style text (e.g. underline, make bold, etc.)
<a name="line45"></a> * @constructor
<a name="line46"></a> * @extends {goog.editor.Plugin}
<a name="line47"></a> */
<a name="line48"></a>goog.editor.plugins.BasicTextFormatter = function() {
<a name="line49"></a>  goog.editor.Plugin.call(this);
<a name="line50"></a>};
<a name="line51"></a>goog.inherits(goog.editor.plugins.BasicTextFormatter, goog.editor.Plugin);
<a name="line52"></a>
<a name="line53"></a>
<a name="line54"></a>/** @override */
<a name="line55"></a>goog.editor.plugins.BasicTextFormatter.prototype.getTrogClassId = function() {
<a name="line56"></a>  return &#39;BTF&#39;;
<a name="line57"></a>};
<a name="line58"></a>
<a name="line59"></a>
<a name="line60"></a>/**
<a name="line61"></a> * Logging object.
<a name="line62"></a> * @type {goog.debug.Logger}
<a name="line63"></a> * @protected
<a name="line64"></a> * @override
<a name="line65"></a> */
<a name="line66"></a>goog.editor.plugins.BasicTextFormatter.prototype.logger =
<a name="line67"></a>    goog.debug.Logger.getLogger(&#39;goog.editor.plugins.BasicTextFormatter&#39;);
<a name="line68"></a>
<a name="line69"></a>
<a name="line70"></a>/**
<a name="line71"></a> * Commands implemented by this plugin.
<a name="line72"></a> * @enum {string}
<a name="line73"></a> */
<a name="line74"></a>goog.editor.plugins.BasicTextFormatter.COMMAND = {
<a name="line75"></a>  LINK: &#39;+link&#39;,
<a name="line76"></a>  FORMAT_BLOCK: &#39;+formatBlock&#39;,
<a name="line77"></a>  INDENT: &#39;+indent&#39;,
<a name="line78"></a>  OUTDENT: &#39;+outdent&#39;,
<a name="line79"></a>  STRIKE_THROUGH: &#39;+strikeThrough&#39;,
<a name="line80"></a>  HORIZONTAL_RULE: &#39;+insertHorizontalRule&#39;,
<a name="line81"></a>  SUBSCRIPT: &#39;+subscript&#39;,
<a name="line82"></a>  SUPERSCRIPT: &#39;+superscript&#39;,
<a name="line83"></a>  UNDERLINE: &#39;+underline&#39;,
<a name="line84"></a>  BOLD: &#39;+bold&#39;,
<a name="line85"></a>  ITALIC: &#39;+italic&#39;,
<a name="line86"></a>  FONT_SIZE: &#39;+fontSize&#39;,
<a name="line87"></a>  FONT_FACE: &#39;+fontName&#39;,
<a name="line88"></a>  FONT_COLOR: &#39;+foreColor&#39;,
<a name="line89"></a>  BACKGROUND_COLOR: &#39;+backColor&#39;,
<a name="line90"></a>  ORDERED_LIST: &#39;+insertOrderedList&#39;,
<a name="line91"></a>  UNORDERED_LIST: &#39;+insertUnorderedList&#39;,
<a name="line92"></a>  JUSTIFY_CENTER: &#39;+justifyCenter&#39;,
<a name="line93"></a>  JUSTIFY_FULL: &#39;+justifyFull&#39;,
<a name="line94"></a>  JUSTIFY_RIGHT: &#39;+justifyRight&#39;,
<a name="line95"></a>  JUSTIFY_LEFT: &#39;+justifyLeft&#39;
<a name="line96"></a>};
<a name="line97"></a>
<a name="line98"></a>
<a name="line99"></a>/**
<a name="line100"></a> * Inverse map of execCommand strings to
<a name="line101"></a> * {@link goog.editor.plugins.BasicTextFormatter.COMMAND} constants. Used to
<a name="line102"></a> * determine whether a string corresponds to a command this plugin
<a name="line103"></a> * handles in O(1) time.
<a name="line104"></a> * @type {Object}
<a name="line105"></a> * @private
<a name="line106"></a> */
<a name="line107"></a>goog.editor.plugins.BasicTextFormatter.SUPPORTED_COMMANDS_ =
<a name="line108"></a>    goog.object.transpose(goog.editor.plugins.BasicTextFormatter.COMMAND);
<a name="line109"></a>
<a name="line110"></a>
<a name="line111"></a>/**
<a name="line112"></a> * Whether the string corresponds to a command this plugin handles.
<a name="line113"></a> * @param {string} command Command string to check.
<a name="line114"></a> * @return {boolean} Whether the string corresponds to a command
<a name="line115"></a> *     this plugin handles.
<a name="line116"></a> */
<a name="line117"></a>goog.editor.plugins.BasicTextFormatter.prototype.isSupportedCommand = function(
<a name="line118"></a>    command) {
<a name="line119"></a>  // TODO(user): restore this to simple check once table editing
<a name="line120"></a>  // is moved out into its own plugin
<a name="line121"></a>  return command in goog.editor.plugins.BasicTextFormatter.SUPPORTED_COMMANDS_;
<a name="line122"></a>};
<a name="line123"></a>
<a name="line124"></a>
<a name="line125"></a>/**
<a name="line126"></a> * @return {goog.dom.AbstractRange} The closure range object that wraps the
<a name="line127"></a> *     current user selection.
<a name="line128"></a> * @private
<a name="line129"></a> */
<a name="line130"></a>goog.editor.plugins.BasicTextFormatter.prototype.getRange_ = function() {
<a name="line131"></a>  return this.fieldObject.getRange();
<a name="line132"></a>};
<a name="line133"></a>
<a name="line134"></a>
<a name="line135"></a>/**
<a name="line136"></a> * @return {Document} The document object associated with the currently active
<a name="line137"></a> *     field.
<a name="line138"></a> * @private
<a name="line139"></a> */
<a name="line140"></a>goog.editor.plugins.BasicTextFormatter.prototype.getDocument_ = function() {
<a name="line141"></a>  return this.getFieldDomHelper().getDocument();
<a name="line142"></a>};
<a name="line143"></a>
<a name="line144"></a>
<a name="line145"></a>/**
<a name="line146"></a> * Execute a user-initiated command.
<a name="line147"></a> * @param {goog.editor.plugins.BasicTextFormatter.COMMAND} command Command
<a name="line148"></a> *     to execute.
<a name="line149"></a> * @param {...string|number|boolean|null} var_args For color commands, this
<a name="line150"></a> *     should be the hex color (with the #). For FORMAT_BLOCK, this should be
<a name="line151"></a> *     the goog.editor.plugins.BasicTextFormatter.BLOCK_COMMAND.
<a name="line152"></a> *     It will be unused for other commands.
<a name="line153"></a> * @return {Object|undefined} The result of the command.
<a name="line154"></a> */
<a name="line155"></a>goog.editor.plugins.BasicTextFormatter.prototype.execCommandInternal = function(
<a name="line156"></a>    command, var_args) {
<a name="line157"></a>  var preserveDir, styleWithCss, needsFormatBlockDiv, hasDummySelection;
<a name="line158"></a>  var result;
<a name="line159"></a>  var opt_arg = arguments[1];
<a name="line160"></a>
<a name="line161"></a>  switch (command) {
<a name="line162"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.BACKGROUND_COLOR:
<a name="line163"></a>      // Don&#39;t bother for no color selected, color picker is resetting itself.
<a name="line164"></a>      if (!goog.isNull(opt_arg)) {
<a name="line165"></a>        if (goog.editor.BrowserFeature.EATS_EMPTY_BACKGROUND_COLOR) {
<a name="line166"></a>          this.applyBgColorManually_(opt_arg);
<a name="line167"></a>        } else if (goog.userAgent.OPERA) {
<a name="line168"></a>          // backColor will color the block level element instead of
<a name="line169"></a>          // the selected span of text in Opera.
<a name="line170"></a>          this.execCommandHelper_(&#39;hiliteColor&#39;, opt_arg);
<a name="line171"></a>        } else {
<a name="line172"></a>          this.execCommandHelper_(command, opt_arg);
<a name="line173"></a>        }
<a name="line174"></a>      }
<a name="line175"></a>      break;
<a name="line176"></a>
<a name="line177"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.LINK:
<a name="line178"></a>      result = this.toggleLink_(opt_arg);
<a name="line179"></a>      break;
<a name="line180"></a>
<a name="line181"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_CENTER:
<a name="line182"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_FULL:
<a name="line183"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_RIGHT:
<a name="line184"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_LEFT:
<a name="line185"></a>      this.justify_(command);
<a name="line186"></a>      break;
<a name="line187"></a>
<a name="line188"></a>    default:
<a name="line189"></a>      if (goog.userAgent.IE &amp;&amp;
<a name="line190"></a>          command ==
<a name="line191"></a>              goog.editor.plugins.BasicTextFormatter.COMMAND.FORMAT_BLOCK &amp;&amp;
<a name="line192"></a>          opt_arg) {
<a name="line193"></a>        // IE requires that the argument be in the form of an opening
<a name="line194"></a>        // tag, like &lt;h1&gt;, including angle brackets.  WebKit will accept
<a name="line195"></a>        // the arguemnt with or without brackets, and Firefox pre-3 supports
<a name="line196"></a>        // only a fixed subset of tags with brackets, and prefers without.
<a name="line197"></a>        // So we only add them IE only.
<a name="line198"></a>        opt_arg = &#39;&lt;&#39; + opt_arg + &#39;&gt;&#39;;
<a name="line199"></a>      }
<a name="line200"></a>
<a name="line201"></a>      if (command ==
<a name="line202"></a>          goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_COLOR &amp;&amp;
<a name="line203"></a>          goog.isNull(opt_arg)) {
<a name="line204"></a>        // If we don&#39;t have a color, then FONT_COLOR is a no-op.
<a name="line205"></a>        break;
<a name="line206"></a>      }
<a name="line207"></a>
<a name="line208"></a>      switch (command) {
<a name="line209"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.INDENT:
<a name="line210"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.OUTDENT:
<a name="line211"></a>          if (goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS) {
<a name="line212"></a>            if (goog.userAgent.GECKO) {
<a name="line213"></a>              styleWithCss = true;
<a name="line214"></a>            }
<a name="line215"></a>            if (goog.userAgent.OPERA) {
<a name="line216"></a>              if (command ==
<a name="line217"></a>                  goog.editor.plugins.BasicTextFormatter.COMMAND.OUTDENT) {
<a name="line218"></a>                // styleWithCSS actually sets negative margins on &lt;blockquote&gt;
<a name="line219"></a>                // to outdent them. If the command is enabled without
<a name="line220"></a>                // styleWithCSS flipped on, then the caret is in a blockquote so
<a name="line221"></a>                // styleWithCSS must not be used. But if the command is not
<a name="line222"></a>                // enabled, styleWithCSS should be used so that elements such as
<a name="line223"></a>                // a &lt;div&gt; with a margin-left style can still be outdented.
<a name="line224"></a>                // (Opera bug: CORE-21118)
<a name="line225"></a>                styleWithCss =
<a name="line226"></a>                    !this.getDocument_().queryCommandEnabled(&#39;outdent&#39;);
<a name="line227"></a>              } else {
<a name="line228"></a>                // Always use styleWithCSS for indenting. Otherwise, Opera will
<a name="line229"></a>                // make separate &lt;blockquote&gt;s around *each* indented line,
<a name="line230"></a>                // which adds big default &lt;blockquote&gt; margins between each
<a name="line231"></a>                // indented line.
<a name="line232"></a>                styleWithCss = true;
<a name="line233"></a>              }
<a name="line234"></a>            }
<a name="line235"></a>          }
<a name="line236"></a>          // Fall through.
<a name="line237"></a>
<a name="line238"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.ORDERED_LIST:
<a name="line239"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.UNORDERED_LIST:
<a name="line240"></a>          if (goog.editor.BrowserFeature.LEAVES_P_WHEN_REMOVING_LISTS &amp;&amp;
<a name="line241"></a>              this.queryCommandStateInternal_(this.getDocument_(),
<a name="line242"></a>                  command)) {
<a name="line243"></a>            // IE leaves behind P tags when unapplying lists.
<a name="line244"></a>            // If we&#39;re not in P-mode, then we want divs
<a name="line245"></a>            // So, unlistify, then convert the Ps into divs.
<a name="line246"></a>            needsFormatBlockDiv = this.fieldObject.queryCommandValue(
<a name="line247"></a>                goog.editor.Command.DEFAULT_TAG) != goog.dom.TagName.P;
<a name="line248"></a>          } else if (!goog.editor.BrowserFeature.CAN_LISTIFY_BR) {
<a name="line249"></a>            // IE doesn&#39;t convert BRed line breaks into separate list items.
<a name="line250"></a>            // So convert the BRs to divs, then do the listify.
<a name="line251"></a>            this.convertBreaksToDivs_();
<a name="line252"></a>          }
<a name="line253"></a>
<a name="line254"></a>          // This fix only works in Gecko.
<a name="line255"></a>          if (goog.userAgent.GECKO &amp;&amp;
<a name="line256"></a>              goog.editor.BrowserFeature.FORGETS_FORMATTING_WHEN_LISTIFYING &amp;&amp;
<a name="line257"></a>              !this.queryCommandValue(command)) {
<a name="line258"></a>            hasDummySelection |= this.beforeInsertListGecko_();
<a name="line259"></a>          }
<a name="line260"></a>          // Fall through to preserveDir block
<a name="line261"></a>
<a name="line262"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.FORMAT_BLOCK:
<a name="line263"></a>          // Both FF &amp; IE may lose directionality info. Save/restore it.
<a name="line264"></a>          // TODO(user): Does Safari also need this?
<a name="line265"></a>          // TODO (gmark, jparent): This isn&#39;t ideal because it uses a string
<a name="line266"></a>          // literal, so if the plugin name changes, it would break. We need a
<a name="line267"></a>          // better solution. See also other places in code that use
<a name="line268"></a>          // this.getPluginByClassId(&#39;Bidi&#39;).
<a name="line269"></a>          preserveDir = !!this.fieldObject.getPluginByClassId(&#39;Bidi&#39;);
<a name="line270"></a>          break;
<a name="line271"></a>
<a name="line272"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.SUBSCRIPT:
<a name="line273"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.SUPERSCRIPT:
<a name="line274"></a>          if (goog.editor.BrowserFeature.NESTS_SUBSCRIPT_SUPERSCRIPT) {
<a name="line275"></a>            // This browser nests subscript and superscript when both are
<a name="line276"></a>            // applied, instead of canceling out the first when applying the
<a name="line277"></a>            // second.
<a name="line278"></a>            this.applySubscriptSuperscriptWorkarounds_(command);
<a name="line279"></a>          }
<a name="line280"></a>          break;
<a name="line281"></a>
<a name="line282"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.UNDERLINE:
<a name="line283"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.BOLD:
<a name="line284"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.ITALIC:
<a name="line285"></a>          // If we are applying the formatting, then we want to have
<a name="line286"></a>          // styleWithCSS false so that we generate html tags (like &lt;b&gt;).  If we
<a name="line287"></a>          // are unformatting something, we want to have styleWithCSS true so
<a name="line288"></a>          // that we can unformat both html tags and inline styling.
<a name="line289"></a>          // TODO(user): What about WebKit and Opera?
<a name="line290"></a>          styleWithCss = goog.userAgent.GECKO &amp;&amp;
<a name="line291"></a>                         goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS &amp;&amp;
<a name="line292"></a>                         this.queryCommandValue(command);
<a name="line293"></a>          break;
<a name="line294"></a>
<a name="line295"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_COLOR:
<a name="line296"></a>        case goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_FACE:
<a name="line297"></a>          // It is very expensive in FF (order of magnitude difference) to use
<a name="line298"></a>          // font tags instead of styled spans. Whenever possible,
<a name="line299"></a>          // force FF to use spans.
<a name="line300"></a>          // Font size is very expensive too, but FF always uses font tags,
<a name="line301"></a>          // regardless of which styleWithCSS value you use.
<a name="line302"></a>          styleWithCss = goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS &amp;&amp;
<a name="line303"></a>                         goog.userAgent.GECKO;
<a name="line304"></a>      }
<a name="line305"></a>
<a name="line306"></a>      /**
<a name="line307"></a>       * Cases where we just use the default execCommand (in addition
<a name="line308"></a>       * to the above fall-throughs)
<a name="line309"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.STRIKE_THROUGH:
<a name="line310"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.HORIZONTAL_RULE:
<a name="line311"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.SUBSCRIPT:
<a name="line312"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.SUPERSCRIPT:
<a name="line313"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.UNDERLINE:
<a name="line314"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.BOLD:
<a name="line315"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.ITALIC:
<a name="line316"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_SIZE:
<a name="line317"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_FACE:
<a name="line318"></a>       */
<a name="line319"></a>      this.execCommandHelper_(command, opt_arg, preserveDir, !!styleWithCss);
<a name="line320"></a>
<a name="line321"></a>      if (hasDummySelection) {
<a name="line322"></a>        this.getDocument_().execCommand(&#39;Delete&#39;, false, true);
<a name="line323"></a>      }
<a name="line324"></a>
<a name="line325"></a>      if (needsFormatBlockDiv) {
<a name="line326"></a>        this.getDocument_().execCommand(&#39;FormatBlock&#39;, false, &#39;&lt;div&gt;&#39;);
<a name="line327"></a>      }
<a name="line328"></a>  }
<a name="line329"></a>  // FF loses focus, so we have to set the focus back to the document or the
<a name="line330"></a>  // user can&#39;t type after selecting from menu.  In IE, focus is set correctly
<a name="line331"></a>  // and resetting it here messes it up.
<a name="line332"></a>  if (goog.userAgent.GECKO &amp;&amp; !this.fieldObject.inModalMode()) {
<a name="line333"></a>    this.focusField_();
<a name="line334"></a>  }
<a name="line335"></a>  return result;
<a name="line336"></a>};
<a name="line337"></a>
<a name="line338"></a>
<a name="line339"></a>/**
<a name="line340"></a> * Focuses on the field.
<a name="line341"></a> * @private
<a name="line342"></a> */
<a name="line343"></a>goog.editor.plugins.BasicTextFormatter.prototype.focusField_ = function() {
<a name="line344"></a>  this.getFieldDomHelper().getWindow().focus();
<a name="line345"></a>};
<a name="line346"></a>
<a name="line347"></a>
<a name="line348"></a>/**
<a name="line349"></a> * Gets the command value.
<a name="line350"></a> * @param {string} command The command value to get.
<a name="line351"></a> * @return {string|boolean|null} The current value of the command in the given
<a name="line352"></a> *     selection.  NOTE: This return type list is not documented in MSDN or MDC
<a name="line353"></a> *     and has been constructed from experience.  Please update it
<a name="line354"></a> *     if necessary.
<a name="line355"></a> */
<a name="line356"></a>goog.editor.plugins.BasicTextFormatter.prototype.queryCommandValue = function(
<a name="line357"></a>    command) {
<a name="line358"></a>  var styleWithCss;
<a name="line359"></a>  switch (command) {
<a name="line360"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.LINK:
<a name="line361"></a>      return this.isNodeInState_(goog.dom.TagName.A);
<a name="line362"></a>
<a name="line363"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_CENTER:
<a name="line364"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_FULL:
<a name="line365"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_RIGHT:
<a name="line366"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.JUSTIFY_LEFT:
<a name="line367"></a>      return this.isJustification_(command);
<a name="line368"></a>
<a name="line369"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.FORMAT_BLOCK:
<a name="line370"></a>      // TODO(nicksantos): See if we can use queryCommandValue here.
<a name="line371"></a>      return goog.editor.plugins.BasicTextFormatter.getSelectionBlockState_(
<a name="line372"></a>          this.fieldObject.getRange());
<a name="line373"></a>
<a name="line374"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.INDENT:
<a name="line375"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.OUTDENT:
<a name="line376"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.HORIZONTAL_RULE:
<a name="line377"></a>      // TODO: See if there are reasonable results to return for
<a name="line378"></a>      // these commands.
<a name="line379"></a>      return false;
<a name="line380"></a>
<a name="line381"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_SIZE:
<a name="line382"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_FACE:
<a name="line383"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.FONT_COLOR:
<a name="line384"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.BACKGROUND_COLOR:
<a name="line385"></a>      // We use queryCommandValue here since we don&#39;t just want to know if a
<a name="line386"></a>      // color/fontface/fontsize is applied, we want to know WHICH one it is.
<a name="line387"></a>      return this.queryCommandValueInternal_(this.getDocument_(), command,
<a name="line388"></a>          goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS &amp;&amp;
<a name="line389"></a>          goog.userAgent.GECKO);
<a name="line390"></a>
<a name="line391"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.UNDERLINE:
<a name="line392"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.BOLD:
<a name="line393"></a>    case goog.editor.plugins.BasicTextFormatter.COMMAND.ITALIC:
<a name="line394"></a>      styleWithCss = goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS &amp;&amp;
<a name="line395"></a>                     goog.userAgent.GECKO;
<a name="line396"></a>
<a name="line397"></a>    default:
<a name="line398"></a>      /**
<a name="line399"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.STRIKE_THROUGH
<a name="line400"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.SUBSCRIPT
<a name="line401"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.SUPERSCRIPT
<a name="line402"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.UNDERLINE
<a name="line403"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.BOLD
<a name="line404"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.ITALIC
<a name="line405"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.ORDERED_LIST
<a name="line406"></a>       * goog.editor.plugins.BasicTextFormatter.COMMAND.UNORDERED_LIST
<a name="line407"></a>       */
<a name="line408"></a>      // This only works for commands that use the default execCommand
<a name="line409"></a>      return this.queryCommandStateInternal_(this.getDocument_(), command,
<a name="line410"></a>          styleWithCss);
<a name="line411"></a>  }
<a name="line412"></a>};
<a name="line413"></a>
<a name="line414"></a>
<a name="line415"></a>/**
<a name="line416"></a> * @override
<a name="line417"></a> */
<a name="line418"></a>goog.editor.plugins.BasicTextFormatter.prototype.prepareContentsHtml =
<a name="line419"></a>    function(html) {
<a name="line420"></a>  // If the browser collapses empty nodes and the field has only a script
<a name="line421"></a>  // tag in it, then it will collapse this node. Which will mean the user
<a name="line422"></a>  // can&#39;t click into it to edit it.
<a name="line423"></a>  if (goog.editor.BrowserFeature.COLLAPSES_EMPTY_NODES &amp;&amp;
<a name="line424"></a>      html.match(/^\s*&lt;script/i)) {
<a name="line425"></a>    html = &#39;&amp;nbsp;&#39; + html;
<a name="line426"></a>  }
<a name="line427"></a>
<a name="line428"></a>  if (goog.editor.BrowserFeature.CONVERT_TO_B_AND_I_TAGS) {
<a name="line429"></a>    // Some browsers (FF) can&#39;t undo strong/em in some cases, but can undo b/i!
<a name="line430"></a>    html = html.replace(/&lt;(\/?)strong([^\w])/gi, &#39;&lt;$1b$2&#39;);
<a name="line431"></a>    html = html.replace(/&lt;(\/?)em([^\w])/gi, &#39;&lt;$1i$2&#39;);
<a name="line432"></a>  }
<a name="line433"></a>
<a name="line434"></a>  return html;
<a name="line435"></a>};
<a name="line436"></a>
<a name="line437"></a>
<a name="line438"></a>/**
<a name="line439"></a> * @override
<a name="line440"></a> */
<a name="line441"></a>goog.editor.plugins.BasicTextFormatter.prototype.cleanContentsDom =
<a name="line442"></a>    function(fieldCopy) {
<a name="line443"></a>  var images = fieldCopy.getElementsByTagName(goog.dom.TagName.IMG);
<a name="line444"></a>  for (var i = 0, image; image = images[i]; i++) {
<a name="line445"></a>    if (goog.editor.BrowserFeature.SHOWS_CUSTOM_ATTRS_IN_INNER_HTML) {
<a name="line446"></a>      // Only need to remove these attributes in IE because
<a name="line447"></a>      // Firefox and Safari don&#39;t show custom attributes in the innerHTML.
<a name="line448"></a>      image.removeAttribute(&#39;tabIndex&#39;);
<a name="line449"></a>      image.removeAttribute(&#39;tabIndexSet&#39;);
<a name="line450"></a>      goog.removeUid(image);
<a name="line451"></a>
<a name="line452"></a>      // Declare oldTypeIndex for the compiler. The associated plugin may not be
<a name="line453"></a>      // included in the compiled bundle.
<a name="line454"></a>      /** @type {string} */ image.oldTabIndex;
<a name="line455"></a>
<a name="line456"></a>      // oldTabIndex will only be set if
<a name="line457"></a>      // goog.editor.BrowserFeature.TABS_THROUGH_IMAGES is true and we&#39;re in
<a name="line458"></a>      // P-on-enter mode.
<a name="line459"></a>      if (image.oldTabIndex) {
<a name="line460"></a>        image.tabIndex = image.oldTabIndex;
<a name="line461"></a>      }
<a name="line462"></a>    }
<a name="line463"></a>  }
<a name="line464"></a>};
<a name="line465"></a>
<a name="line466"></a>
<a name="line467"></a>/**
<a name="line468"></a> * @override
<a name="line469"></a> */
<a name="line470"></a>goog.editor.plugins.BasicTextFormatter.prototype.cleanContentsHtml =
<a name="line471"></a>    function(html) {
<a name="line472"></a>  if (goog.editor.BrowserFeature.MOVES_STYLE_TO_HEAD) {
<a name="line473"></a>    // Safari creates a new &lt;head&gt; element for &lt;style&gt; tags, so prepend their
<a name="line474"></a>    // contents to the output.
<a name="line475"></a>    var heads = this.fieldObject.getEditableDomHelper().
<a name="line476"></a>        getElementsByTagNameAndClass(goog.dom.TagName.HEAD);
<a name="line477"></a>    var stylesHtmlArr = [];
<a name="line478"></a>
<a name="line479"></a>    // i starts at 1 so we don&#39;t copy in the original, legitimate &lt;head&gt;.
<a name="line480"></a>    var numHeads = heads.length;
<a name="line481"></a>    for (var i = 1; i &lt; numHeads; ++i) {
<a name="line482"></a>      var styles = heads[i].getElementsByTagName(goog.dom.TagName.STYLE);
<a name="line483"></a>      var numStyles = styles.length;
<a name="line484"></a>      for (var j = 0; j &lt; numStyles; ++j) {
<a name="line485"></a>        stylesHtmlArr.push(styles[j].outerHTML);
<a name="line486"></a>      }
<a name="line487"></a>    }
<a name="line488"></a>    return stylesHtmlArr.join(&#39;&#39;) + html;
<a name="line489"></a>  }
<a name="line490"></a>
<a name="line491"></a>  return html;
<a name="line492"></a>};
<a name="line493"></a>
<a name="line494"></a>
<a name="line495"></a>/**
<a name="line496"></a> * @override
<a name="line497"></a> */
<a name="line498"></a>goog.editor.plugins.BasicTextFormatter.prototype.handleKeyboardShortcut =
<a name="line499"></a>    function(e, key, isModifierPressed) {
<a name="line500"></a>  if (!isModifierPressed) {
<a name="line501"></a>    return false;
<a name="line502"></a>  }
<a name="line503"></a>  var command;
<a name="line504"></a>  switch (key) {
<a name="line505"></a>    case &#39;b&#39;: // Ctrl+B
<a name="line506"></a>      command = goog.editor.plugins.BasicTextFormatter.COMMAND.BOLD;
<a name="line507"></a>      break;
<a name="line508"></a>    case &#39;i&#39;: // Ctrl+I
<a name="line509"></a>      command = goog.editor.plugins.BasicTextFormatter.COMMAND.ITALIC;
<a name="line510"></a>      break;
<a name="line511"></a>    case &#39;u&#39;: // Ctrl+U
<a name="line512"></a>      command = goog.editor.plugins.BasicTextFormatter.COMMAND.UNDERLINE;
<a name="line513"></a>      break;
<a name="line514"></a>    case &#39;s&#39;: // Ctrl+S
<a name="line515"></a>      // TODO(user): This doesn&#39;t belong in here.  Clients should handle
<a name="line516"></a>      // this themselves.
<a name="line517"></a>      // Catching control + s prevents the annoying browser save dialog
<a name="line518"></a>      // from appearing.
<a name="line519"></a>      return true;
<a name="line520"></a>  }
<a name="line521"></a>
<a name="line522"></a>  if (command) {
<a name="line523"></a>    this.fieldObject.execCommand(command);
<a name="line524"></a>    return true;
<a name="line525"></a>  }
<a name="line526"></a>
<a name="line527"></a>  return false;
<a name="line528"></a>};
<a name="line529"></a>
<a name="line530"></a>
<a name="line531"></a>// Helpers for execCommand
<a name="line532"></a>
<a name="line533"></a>
<a name="line534"></a>/**
<a name="line535"></a> * Regular expression to match BRs in HTML. Saves the BRs&#39; attributes in $1 for
<a name="line536"></a> * use with replace(). In non-IE browsers, does not match BRs adjacent to an
<a name="line537"></a> * opening or closing DIV or P tag, since nonrendered BR elements can occur at
<a name="line538"></a> * the end of block level containers in those browsers&#39; editors.
<a name="line539"></a> * @type {RegExp}
<a name="line540"></a> * @private
<a name="line541"></a> */
<a name="line542"></a>goog.editor.plugins.BasicTextFormatter.BR_REGEXP_ =
<a name="line543"></a>    goog.userAgent.IE ? /&lt;br([^\/&gt;]*)\/?&gt;/gi :
<a name="line544"></a>                        /&lt;br([^\/&gt;]*)\/?&gt;(?!&lt;\/(div|p)&gt;)/gi;
<a name="line545"></a>
<a name="line546"></a>
<a name="line547"></a>/**
<a name="line548"></a> * Convert BRs in the selection to divs.
<a name="line549"></a> * This is only intended to be used in IE and Opera.
<a name="line550"></a> * @return {boolean} Whether any BR&#39;s were converted.
<a name="line551"></a> * @private
<a name="line552"></a> */
<a name="line553"></a>goog.editor.plugins.BasicTextFormatter.prototype.convertBreaksToDivs_ =
<a name="line554"></a>    function() {
<a name="line555"></a>  if (!goog.userAgent.IE &amp;&amp; !goog.userAgent.OPERA) {
<a name="line556"></a>    // This function is only supported on IE and Opera.
<a name="line557"></a>    return false;
<a name="line558"></a>  }
<a name="line559"></a>  var range = this.getRange_();
<a name="line560"></a>  var parent = range.getContainerElement();
<a name="line561"></a>  var doc = this.getDocument_();
<a name="line562"></a>
<a name="line563"></a>  goog.editor.plugins.BasicTextFormatter.BR_REGEXP_.lastIndex = 0;
<a name="line564"></a>  // Only mess with the HTML/selection if it contains a BR.
<a name="line565"></a>  if (goog.editor.plugins.BasicTextFormatter.BR_REGEXP_.test(
<a name="line566"></a>      parent.innerHTML)) {
<a name="line567"></a>    // Insert temporary markers to remember the selection.
<a name="line568"></a>    var savedRange = range.saveUsingCarets();
<a name="line569"></a>
<a name="line570"></a>    if (parent.tagName == goog.dom.TagName.P) {
<a name="line571"></a>      // Can&#39;t append paragraphs to paragraph tags. Throws an exception in IE.
<a name="line572"></a>      goog.editor.plugins.BasicTextFormatter.convertParagraphToDiv_(
<a name="line573"></a>          parent, true);
<a name="line574"></a>    } else {
<a name="line575"></a>      // Used to do:
<a name="line576"></a>      // IE: &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; --&gt; &lt;div&gt;foo&lt;p id=&quot;temp_br&quot;&gt;bar&lt;/div&gt;
<a name="line577"></a>      // Opera: &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; --&gt; &lt;div&gt;foo&lt;p class=&quot;temp_br&quot;&gt;bar&lt;/div&gt;
<a name="line578"></a>      // To fix bug 1939883, now does for both:
<a name="line579"></a>      // &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; --&gt; &lt;div&gt;foo&lt;p trtempbr=&quot;temp_br&quot;&gt;bar&lt;/div&gt;
<a name="line580"></a>      // TODO(user): Confirm if there&#39;s any way to skip this
<a name="line581"></a>      // intermediate step of converting br&#39;s to p&#39;s before converting those to
<a name="line582"></a>      // div&#39;s. The reason may be hidden in CLs 5332866 and 8530601.
<a name="line583"></a>      var attribute = &#39;trtempbr&#39;;
<a name="line584"></a>      var value = &#39;temp_br&#39;;
<a name="line585"></a>      parent.innerHTML = parent.innerHTML.replace(
<a name="line586"></a>          goog.editor.plugins.BasicTextFormatter.BR_REGEXP_,
<a name="line587"></a>          &#39;&lt;p$1 &#39; + attribute + &#39;=&quot;&#39; + value + &#39;&quot;&gt;&#39;);
<a name="line588"></a>
<a name="line589"></a>      var paragraphs =
<a name="line590"></a>          goog.array.toArray(parent.getElementsByTagName(goog.dom.TagName.P));
<a name="line591"></a>      goog.iter.forEach(paragraphs, function(paragraph) {
<a name="line592"></a>        if (paragraph.getAttribute(attribute) == value) {
<a name="line593"></a>          paragraph.removeAttribute(attribute);
<a name="line594"></a>          if (goog.string.isBreakingWhitespace(
<a name="line595"></a>              goog.dom.getTextContent(paragraph))) {
<a name="line596"></a>            // Prevent the empty blocks from collapsing.
<a name="line597"></a>            // A &lt;BR&gt; is preferable because it doesn&#39;t result in any text being
<a name="line598"></a>            // added to the &quot;blank&quot; line. In IE, however, it is possible to
<a name="line599"></a>            // place the caret after the &lt;br&gt;, which effectively creates a
<a name="line600"></a>            // visible line break. Because of this, we have to resort to using a
<a name="line601"></a>            // &amp;nbsp; in IE.
<a name="line602"></a>            var child = goog.userAgent.IE ?
<a name="line603"></a>                doc.createTextNode(goog.string.Unicode.NBSP) :
<a name="line604"></a>                doc.createElement(goog.dom.TagName.BR);
<a name="line605"></a>            paragraph.appendChild(child);
<a name="line606"></a>          }
<a name="line607"></a>          goog.editor.plugins.BasicTextFormatter.convertParagraphToDiv_(
<a name="line608"></a>              paragraph);
<a name="line609"></a>        }
<a name="line610"></a>      });
<a name="line611"></a>    }
<a name="line612"></a>
<a name="line613"></a>    // Select the previously selected text so we only listify
<a name="line614"></a>    // the selected portion and maintain the user&#39;s selection.
<a name="line615"></a>    savedRange.restore();
<a name="line616"></a>    return true;
<a name="line617"></a>  }
<a name="line618"></a>
<a name="line619"></a>  return false;
<a name="line620"></a>};
<a name="line621"></a>
<a name="line622"></a>
<a name="line623"></a>/**
<a name="line624"></a> * Convert the given paragraph to being a div. This clobbers the
<a name="line625"></a> * passed-in node!
<a name="line626"></a> * This is only intended to be used in IE and Opera.
<a name="line627"></a> * @param {Node} paragraph Paragragh to convert to a div.
<a name="line628"></a> * @param {boolean=} opt_convertBrs If true, also convert BRs to divs.
<a name="line629"></a> * @private
<a name="line630"></a> */
<a name="line631"></a>goog.editor.plugins.BasicTextFormatter.convertParagraphToDiv_ =
<a name="line632"></a>    function(paragraph, opt_convertBrs) {
<a name="line633"></a>  if (!goog.userAgent.IE &amp;&amp; !goog.userAgent.OPERA) {
<a name="line634"></a>    // This function is only supported on IE and Opera.
<a name="line635"></a>    return;
<a name="line636"></a>  }
<a name="line637"></a>  var outerHTML = paragraph.outerHTML.replace(/&lt;(\/?)p/gi, &#39;&lt;$1div&#39;);
<a name="line638"></a>  if (opt_convertBrs) {
<a name="line639"></a>    // IE fills in the closing div tag if it&#39;s missing!
<a name="line640"></a>    outerHTML = outerHTML.replace(
<a name="line641"></a>        goog.editor.plugins.BasicTextFormatter.BR_REGEXP_,
<a name="line642"></a>        &#39;&lt;/div&gt;&lt;div$1&gt;&#39;);
<a name="line643"></a>  }
<a name="line644"></a>  if (goog.userAgent.OPERA &amp;&amp; !/&lt;\/div&gt;$/i.test(outerHTML)) {
<a name="line645"></a>    // Opera doesn&#39;t automatically add the closing tag, so add it if needed.
<a name="line646"></a>    outerHTML += &#39;&lt;/div&gt;&#39;;
<a name="line647"></a>  }
<a name="line648"></a>  paragraph.outerHTML = outerHTML;
<a name="line649"></a>};
<a name="line650"></a>
<a name="line651"></a>
<a name="line652"></a>/**
<a name="line653"></a> * If this is a goog.editor.plugins.BasicTextFormatter.COMMAND,
<a name="line654"></a> * convert it to something that we can pass into execCommand,
<a name="line655"></a> * queryCommandState, etc.
<a name="line656"></a> *
<a name="line657"></a> * TODO(user): Consider doing away with the + and converter completely.
<a name="line658"></a> *
<a name="line659"></a> * @param {goog.editor.plugins.BasicTextFormatter.COMMAND|string}
<a name="line660"></a> *     command A command key.
<a name="line661"></a> * @return {string} The equivalent execCommand command.
<a name="line662"></a> * @private
<a name="line663"></a> */
<a name="line664"></a>goog.editor.plugins.BasicTextFormatter.convertToRealExecCommand_ = function(
<a name="line665"></a>    command) {
<a name="line666"></a>  return command.indexOf(&#39;+&#39;) == 0 ? command.substring(1) : command;
<a name="line667"></a>};
<a name="line668"></a>
<a name="line669"></a>
<a name="line670"></a>/**
<a name="line671"></a> * Justify the text in the selection.
<a name="line672"></a> * @param {string} command The type of justification to perform.
<a name="line673"></a> * @private
<a name="line674"></a> */
<a name="line675"></a>goog.editor.plugins.BasicTextFormatter.prototype.justify_ = function(command) {
<a name="line676"></a>  this.execCommandHelper_(command, null, false, true);
<a name="line677"></a>  // Firefox cannot justify divs.  In fact, justifying divs results in removing
<a name="line678"></a>  // the divs and replacing them with brs.  So &quot;&lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&quot;
<a name="line679"></a>  // becomes &quot;foo&lt;br&gt;bar&quot; after alignment is applied.  However, if you justify
<a name="line680"></a>  // again, then you get &quot;&lt;div style=&#39;text-align: right&#39;&gt;foo&lt;br&gt;bar&lt;/div&gt;&quot;,
<a name="line681"></a>  // which at least looks visually correct.  Since justification is (normally)
<a name="line682"></a>  // idempotent, it isn&#39;t a problem when the selection does not contain divs to
<a name="line683"></a>  // apply justifcation again.
<a name="line684"></a>  if (goog.userAgent.GECKO) {
<a name="line685"></a>    this.execCommandHelper_(command, null, false, true);
<a name="line686"></a>  }
<a name="line687"></a>
<a name="line688"></a>  // Convert all block elements in the selection to use CSS text-align
<a name="line689"></a>  // instead of the align property. This works better because the align
<a name="line690"></a>  // property is overridden by the CSS text-align property.
<a name="line691"></a>  //
<a name="line692"></a>  // Only for browsers that can&#39;t handle this by the styleWithCSS execCommand,
<a name="line693"></a>  // which allows us to specify if we should insert align or text-align.
<a name="line694"></a>  // TODO(user): What about WebKit or Opera?
<a name="line695"></a>  if (!(goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS &amp;&amp;
<a name="line696"></a>        goog.userAgent.GECKO)) {
<a name="line697"></a>    goog.iter.forEach(this.fieldObject.getRange(),
<a name="line698"></a>        goog.editor.plugins.BasicTextFormatter.convertContainerToTextAlign_);
<a name="line699"></a>  }
<a name="line700"></a>};
<a name="line701"></a>
<a name="line702"></a>
<a name="line703"></a>/**
<a name="line704"></a> * Converts the block element containing the given node to use CSS text-align
<a name="line705"></a> * instead of the align property.
<a name="line706"></a> * @param {Node} node The node to convert the container of.
<a name="line707"></a> * @private
<a name="line708"></a> */
<a name="line709"></a>goog.editor.plugins.BasicTextFormatter.convertContainerToTextAlign_ =
<a name="line710"></a>    function(node) {
<a name="line711"></a>  var container = goog.editor.style.getContainer(node);
<a name="line712"></a>
<a name="line713"></a>  // TODO(user): Fix this so that it doesn&#39;t screw up tables.
<a name="line714"></a>  if (container.align) {
<a name="line715"></a>    container.style.textAlign = container.align;
<a name="line716"></a>    container.removeAttribute(&#39;align&#39;);
<a name="line717"></a>  }
<a name="line718"></a>};
<a name="line719"></a>
<a name="line720"></a>
<a name="line721"></a>/**
<a name="line722"></a> * Perform an execCommand on the active document.
<a name="line723"></a> * @param {string} command The command to execute.
<a name="line724"></a> * @param {string|number|boolean|null=} opt_value Optional value.
<a name="line725"></a> * @param {boolean=} opt_preserveDir Set true to make sure that command does not
<a name="line726"></a> *     change directionality of the selected text (works only if all selected
<a name="line727"></a> *     text has the same directionality, otherwise ignored). Should not be true
<a name="line728"></a> *     if bidi plugin is not loaded.
<a name="line729"></a> * @param {boolean=} opt_styleWithCss Set to true to ask the browser to use CSS
<a name="line730"></a> *     to perform the execCommand.
<a name="line731"></a> * @private
<a name="line732"></a> */
<a name="line733"></a>goog.editor.plugins.BasicTextFormatter.prototype.execCommandHelper_ = function(
<a name="line734"></a>    command, opt_value, opt_preserveDir, opt_styleWithCss) {
<a name="line735"></a>  // There is a bug in FF: some commands do not preserve attributes of the
<a name="line736"></a>  // block-level elements they replace.
<a name="line737"></a>  // This (among the rest) leads to loss of directionality information.
<a name="line738"></a>  // For now we use a hack (when opt_preserveDir==true) to avoid this
<a name="line739"></a>  // directionality problem in the simplest cases.
<a name="line740"></a>  // Known affected commands: formatBlock, insertOrderedList,
<a name="line741"></a>  // insertUnorderedList, indent, outdent.
<a name="line742"></a>  // A similar problem occurs in IE when insertOrderedList or
<a name="line743"></a>  // insertUnorderedList remove existing list.
<a name="line744"></a>  var dir = null;
<a name="line745"></a>  if (opt_preserveDir) {
<a name="line746"></a>    dir =
<a name="line747"></a>        this.fieldObject.queryCommandValue(
<a name="line748"></a>            goog.editor.Command.DIR_RTL) ? &#39;rtl&#39; :
<a name="line749"></a>        this.fieldObject.queryCommandValue(
<a name="line750"></a>            goog.editor.Command.DIR_LTR) ? &#39;ltr&#39; :
<a name="line751"></a>        null;
<a name="line752"></a>  }
<a name="line753"></a>
<a name="line754"></a>  command = goog.editor.plugins.BasicTextFormatter.convertToRealExecCommand_(
<a name="line755"></a>      command);
<a name="line756"></a>
<a name="line757"></a>  var endDiv, nbsp;
<a name="line758"></a>  if (goog.userAgent.IE) {
<a name="line759"></a>    var ret = this.applyExecCommandIEFixes_(command);
<a name="line760"></a>    endDiv = ret[0];
<a name="line761"></a>    nbsp = ret[1];
<a name="line762"></a>  }
<a name="line763"></a>
<a name="line764"></a>  if (goog.userAgent.WEBKIT) {
<a name="line765"></a>    endDiv = this.applyExecCommandSafariFixes_(command);
<a name="line766"></a>  }
<a name="line767"></a>
<a name="line768"></a>  if (goog.userAgent.GECKO) {
<a name="line769"></a>    this.applyExecCommandGeckoFixes_(command);
<a name="line770"></a>  }
<a name="line771"></a>
<a name="line772"></a>  if (goog.editor.BrowserFeature.DOESNT_OVERRIDE_FONT_SIZE_IN_STYLE_ATTR &amp;&amp;
<a name="line773"></a>      command.toLowerCase() == &#39;fontsize&#39;) {
<a name="line774"></a>    this.removeFontSizeFromStyleAttrs_();
<a name="line775"></a>  }
<a name="line776"></a>
<a name="line777"></a>  var doc = this.getDocument_();
<a name="line778"></a>  if (opt_styleWithCss &amp;&amp;
<a name="line779"></a>      goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS) {
<a name="line780"></a>    doc.execCommand(&#39;styleWithCSS&#39;, false, true);
<a name="line781"></a>    if (goog.userAgent.OPERA) {
<a name="line782"></a>      this.invalidateInlineCss_();
<a name="line783"></a>    }
<a name="line784"></a>  }
<a name="line785"></a>
<a name="line786"></a>  doc.execCommand(command, false, opt_value);
<a name="line787"></a>  if (opt_styleWithCss &amp;&amp;
<a name="line788"></a>      goog.editor.BrowserFeature.HAS_STYLE_WITH_CSS) {
<a name="line789"></a>    // If we enabled styleWithCSS, turn it back off.
<a name="line790"></a>    doc.execCommand(&#39;styleWithCSS&#39;, false, false);
<a name="line791"></a>  }
<a name="line792"></a>
<a name="line793"></a>  if (goog.userAgent.WEBKIT &amp;&amp; !goog.userAgent.isVersion(&#39;526&#39;) &amp;&amp;
<a name="line794"></a>      command.toLowerCase() == &#39;formatblock&#39; &amp;&amp;
<a name="line795"></a>      opt_value &amp;&amp; /^[&lt;]?h\d[&gt;]?$/i.test(opt_value)) {
<a name="line796"></a>    this.cleanUpSafariHeadings_();
<a name="line797"></a>  }
<a name="line798"></a>
<a name="line799"></a>  if (/insert(un)?orderedlist/i.test(command)) {
<a name="line800"></a>    // NOTE(user): This doesn&#39;t check queryCommandState because it seems to
<a name="line801"></a>    // lie. Also, this runs for insertunorderedlist so that the the list
<a name="line802"></a>    // isn&#39;t made up of an &lt;ul&gt; for each &lt;li&gt; - even though it looks the same,
<a name="line803"></a>    // the markup is disgusting.
<a name="line804"></a>    if (goog.userAgent.WEBKIT) {
<a name="line805"></a>      this.fixSafariLists_();
<a name="line806"></a>    }
<a name="line807"></a>    if (goog.userAgent.IE) {
<a name="line808"></a>      this.fixIELists_();
<a name="line809"></a>
<a name="line810"></a>      if (nbsp) {
<a name="line811"></a>        // Remove the text node, if applicable.  Do not try to instead clobber
<a name="line812"></a>        // the contents of the text node if it was added, or the same invalid
<a name="line813"></a>        // node thing as above will happen.  The error won&#39;t happen here, it
<a name="line814"></a>        // will happen after you hit enter and then do anything that loops
<a name="line815"></a>        // through the dom and tries to read that node.
<a name="line816"></a>        goog.dom.removeNode(nbsp);
<a name="line817"></a>      }
<a name="line818"></a>    }
<a name="line819"></a>  }
<a name="line820"></a>
<a name="line821"></a>  if (endDiv) {
<a name="line822"></a>    // Remove the dummy div.
<a name="line823"></a>    goog.dom.removeNode(endDiv);
<a name="line824"></a>  }
<a name="line825"></a>
<a name="line826"></a>  // Restore directionality if required and only when unambigous (dir!=null).
<a name="line827"></a>  if (dir) {
<a name="line828"></a>    this.fieldObject.execCommand(dir);
<a name="line829"></a>  }
<a name="line830"></a>};
<a name="line831"></a>
<a name="line832"></a>
<a name="line833"></a>/**
<a name="line834"></a> * Applies a background color to a selection when the browser can&#39;t do the job.
<a name="line835"></a> *
<a name="line836"></a> * NOTE(nicksantos): If you think this is hacky, you should try applying
<a name="line837"></a> * background color in Opera. It made me cry.
<a name="line838"></a> *
<a name="line839"></a> * @param {string} bgColor backgroundColor from .formatText to .execCommand.
<a name="line840"></a> * @private
<a name="line841"></a> */
<a name="line842"></a>goog.editor.plugins.BasicTextFormatter.prototype.applyBgColorManually_ =
<a name="line843"></a>    function(bgColor) {
<a name="line844"></a>  var needsSpaceInTextNode = goog.userAgent.GECKO;
<a name="line845"></a>  var range = this.fieldObject.getRange();
<a name="line846"></a>  var textNode;
<a name="line847"></a>  var parentTag;
<a name="line848"></a>  if (range &amp;&amp; range.isCollapsed()) {
<a name="line849"></a>    // Hack to handle Firefox bug:
<a name="line850"></a>    // https://bugzilla.mozilla.org/show_bug.cgi?id=279330
<a name="line851"></a>    // execCommand hiliteColor in Firefox on collapsed selection creates
<a name="line852"></a>    // a font tag onkeypress
<a name="line853"></a>    textNode = this.getFieldDomHelper().
<a name="line854"></a>        createTextNode(needsSpaceInTextNode ? &#39; &#39; : &#39;&#39;);
<a name="line855"></a>
<a name="line856"></a>    var containerNode = range.getStartNode();
<a name="line857"></a>    // Check if we&#39;re inside a tag that contains the cursor and nothing else;
<a name="line858"></a>    // if we are, don&#39;t create a dummySpan. Just use this containing tag to
<a name="line859"></a>    // hide the 1-space selection.
<a name="line860"></a>    // If the user sets a background color on a collapsed selection, then sets
<a name="line861"></a>    // another one immediately, we get a span tag with a single empty TextNode.
<a name="line862"></a>    // If the user sets a background color, types, then backspaces, we get a
<a name="line863"></a>    // span tag with nothing inside it (container is the span).
<a name="line864"></a>    parentTag = containerNode.nodeType == goog.dom.NodeType.ELEMENT ?
<a name="line865"></a>        containerNode : containerNode.parentNode;
<a name="line866"></a>
<a name="line867"></a>    if (parentTag.innerHTML == &#39;&#39;) {
<a name="line868"></a>      // There&#39;s an Element to work with
<a name="line869"></a>      // make the space character invisible using a CSS indent hack
<a name="line870"></a>      parentTag.style.textIndent = &#39;-10000px&#39;;
<a name="line871"></a>      parentTag.appendChild(textNode);
<a name="line872"></a>    } else {
<a name="line873"></a>      // No Element to work with; make one
<a name="line874"></a>      // create a span with a space character inside
<a name="line875"></a>      // make the space character invisible using a CSS indent hack
<a name="line876"></a>      parentTag = this.getFieldDomHelper().createDom(&#39;span&#39;,
<a name="line877"></a>          {&#39;style&#39;: &#39;text-indent:-10000px&#39;}, textNode);
<a name="line878"></a>      range.replaceContentsWithNode(parentTag);
<a name="line879"></a>    }
<a name="line880"></a>    goog.dom.Range.createFromNodeContents(textNode).select();
<a name="line881"></a>  }
<a name="line882"></a>
<a name="line883"></a>  this.execCommandHelper_(&#39;hiliteColor&#39;, bgColor, false, true);
<a name="line884"></a>
<a name="line885"></a>  if (textNode) {
<a name="line886"></a>    // eliminate the space if necessary.
<a name="line887"></a>    if (needsSpaceInTextNode) {
<a name="line888"></a>      textNode.data = &#39;&#39;;
<a name="line889"></a>    }
<a name="line890"></a>
<a name="line891"></a>    // eliminate the hack.
<a name="line892"></a>    parentTag.style.textIndent = &#39;&#39;;
<a name="line893"></a>    // execCommand modified our span so we leave it in place.
<a name="line894"></a>  }
<a name="line895"></a>};
<a name="line896"></a>
<a name="line897"></a>
<a name="line898"></a>/**
<a name="line899"></a> * Toggle link for the current selection:
<a name="line900"></a> *   If selection contains a link, unlink it, return null.
<a name="line901"></a> *   Otherwise, make selection into a link, return the link.
<a name="line902"></a> * @param {string=} opt_target Target for the link.
<a name="line903"></a> * @return {goog.editor.Link?} The resulting link, or null if a link was
<a name="line904"></a> *     removed.
<a name="line905"></a> * @private
<a name="line906"></a> */
<a name="line907"></a>goog.editor.plugins.BasicTextFormatter.prototype.toggleLink_ = function(
<a name="line908"></a>    opt_target) {
<a name="line909"></a>  if (!this.fieldObject.isSelectionEditable()) {
<a name="line910"></a>    this.focusField_();
<a name="line911"></a>  }
<a name="line912"></a>
<a name="line913"></a>  var range = this.getRange_();
<a name="line914"></a>  // Since we wrap images in links, its possible that the user selected an
<a name="line915"></a>  // image and clicked link, in which case we want to actually use the
<a name="line916"></a>  // image as the selection.
<a name="line917"></a>  var parent = range &amp;&amp; range.getContainerElement();
<a name="line918"></a>  var link = /** @type {Element} */ (
<a name="line919"></a>      goog.dom.getAncestorByTagNameAndClass(parent, goog.dom.TagName.A));
<a name="line920"></a>  if (link &amp;&amp; goog.editor.node.isEditable(link)) {
<a name="line921"></a>    goog.dom.flattenElement(link);
<a name="line922"></a>  } else {
<a name="line923"></a>    var editableLink = this.createLink_(range, &#39;/&#39;, opt_target);
<a name="line924"></a>    if (editableLink) {
<a name="line925"></a>      if (!this.fieldObject.execCommand(goog.editor.Command.MODAL_LINK_EDITOR,
<a name="line926"></a>          editableLink)) {
<a name="line927"></a>        var url = this.fieldObject.getAppWindow().prompt(
<a name="line928"></a>            goog.ui.editor.messages.MSG_LINK_TO, &#39;http://&#39;);
<a name="line929"></a>        if (url) {
<a name="line930"></a>          editableLink.setTextAndUrl(editableLink.getCurrentText() || url, url);
<a name="line931"></a>          editableLink.placeCursorRightOf();
<a name="line932"></a>        } else {
<a name="line933"></a>          var savedRange = goog.editor.range.saveUsingNormalizedCarets(
<a name="line934"></a>              goog.dom.Range.createFromNodeContents(editableLink.getAnchor()));
<a name="line935"></a>          editableLink.removeLink();
<a name="line936"></a>          savedRange.restore().select();
<a name="line937"></a>          return null;
<a name="line938"></a>        }
<a name="line939"></a>      }
<a name="line940"></a>      return editableLink;
<a name="line941"></a>    }
<a name="line942"></a>  }
<a name="line943"></a>  return null;
<a name="line944"></a>};
<a name="line945"></a>
<a name="line946"></a>
<a name="line947"></a>/**
<a name="line948"></a> * Create a link out of the current selection.  If nothing is selected, insert
<a name="line949"></a> * a new link.  Otherwise, enclose the selection in a link.
<a name="line950"></a> * @param {goog.dom.AbstractRange} range The closure range object for the
<a name="line951"></a> *     current selection.
<a name="line952"></a> * @param {string} url The url to link to.
<a name="line953"></a> * @param {string=} opt_target Target for the link.
<a name="line954"></a> * @return {goog.editor.Link?} The newly created link.
<a name="line955"></a> * @private
<a name="line956"></a> */
<a name="line957"></a>goog.editor.plugins.BasicTextFormatter.prototype.createLink_ = function(range,
<a name="line958"></a>    url, opt_target) {
<a name="line959"></a>  // TODO(robbyw): Handle multi-line links without requiring crazy hacks!
<a name="line960"></a>  var anchor = null;
<a name="line961"></a>  var parent = range &amp;&amp; range.getContainerElement();
<a name="line962"></a>  // We do not yet support creating links around images.  Instead of throwing
<a name="line963"></a>  // lots of js errors, just fail silently.
<a name="line964"></a>  // TODO(user): Add support for linking images.
<a name="line965"></a>  if (parent &amp;&amp; parent.tagName == goog.dom.TagName.IMG) {
<a name="line966"></a>    return null;
<a name="line967"></a>  }
<a name="line968"></a>  if (range &amp;&amp; range.isCollapsed()) {
<a name="line969"></a>    var textRange = range.getTextRange(0).getBrowserRangeObject();
<a name="line970"></a>    if (goog.editor.BrowserFeature.HAS_W3C_RANGES) {
<a name="line971"></a>      anchor = this.getFieldDomHelper().createElement(goog.dom.TagName.A);
<a name="line972"></a>      textRange.insertNode(anchor);
<a name="line973"></a>    } else if (goog.editor.BrowserFeature.HAS_IE_RANGES) {
<a name="line974"></a>      // TODO: Use goog.dom.AbstractRange&#39;s surroundContents
<a name="line975"></a>      textRange.pasteHTML(&quot;&lt;a id=&#39;newLink&#39;&gt;&lt;/a&gt;&quot;);
<a name="line976"></a>      anchor = this.getFieldDomHelper().getElement(&#39;newLink&#39;);
<a name="line977"></a>      anchor.removeAttribute(&#39;id&#39;);
<a name="line978"></a>    }
<a name="line979"></a>  } else {
<a name="line980"></a>    // Create a unique identifier for the link so we can retrieve it later.
<a name="line981"></a>    // execCommand doesn&#39;t return the link to us, and we need a way to find
<a name="line982"></a>    // the newly created link in the dom, and the url is the only property
<a name="line983"></a>    // we have control over, so we set that to be unique and then find it.
<a name="line984"></a>    var uniqueId = goog.string.createUniqueString();
<a name="line985"></a>    this.execCommandHelper_(&#39;CreateLink&#39;, uniqueId);
<a name="line986"></a>    var setHrefAndLink = function(element, index, arr) {
<a name="line987"></a>      // We can&#39;t do straight comparision since the href can contain the
<a name="line988"></a>      // absolute url.
<a name="line989"></a>      if (goog.string.endsWith(element.href, uniqueId)) {
<a name="line990"></a>        anchor = element;
<a name="line991"></a>      }
<a name="line992"></a>    };
<a name="line993"></a>
<a name="line994"></a>    goog.array.forEach(this.fieldObject.getElement().getElementsByTagName(
<a name="line995"></a>        goog.dom.TagName.A), setHrefAndLink);
<a name="line996"></a>  }
<a name="line997"></a>
<a name="line998"></a>  return goog.editor.Link.createNewLink(
<a name="line999"></a>      /** @type {HTMLAnchorElement} */ (anchor), url, opt_target);
<a name="line1000"></a>};
<a name="line1001"></a>
<a name="line1002"></a>
<a name="line1003"></a>//---------------------------------------------------------------------
<a name="line1004"></a>// browser fixes
<a name="line1005"></a>
<a name="line1006"></a>
<a name="line1007"></a>/**
<a name="line1008"></a> * The following execCommands are &quot;broken&quot; in some way - in IE they allow
<a name="line1009"></a> * the nodes outside the contentEditable region to get modified (see
<a name="line1010"></a> * execCommand below for more details).
<a name="line1011"></a> * @const
<a name="line1012"></a> * @private
<a name="line1013"></a> */
<a name="line1014"></a>goog.editor.plugins.BasicTextFormatter.brokenExecCommandsIE_ = {
<a name="line1015"></a>  &#39;indent&#39; : 1,
<a name="line1016"></a>  &#39;outdent&#39; : 1,
<a name="line1017"></a>  &#39;insertOrderedList&#39; : 1,
<a name="line1018"></a>  &#39;insertUnorderedList&#39; : 1,
<a name="line1019"></a>  &#39;justifyCenter&#39; : 1,
<a name="line1020"></a>  &#39;justifyFull&#39; : 1,
<a name="line1021"></a>  &#39;justifyRight&#39;: 1,
<a name="line1022"></a>  &#39;justifyLeft&#39;: 1,
<a name="line1023"></a>  &#39;ltr&#39; : 1,
<a name="line1024"></a>  &#39;rtl&#39; : 1
<a name="line1025"></a>};
<a name="line1026"></a>
<a name="line1027"></a>
<a name="line1028"></a>/**
<a name="line1029"></a> * When the following commands are executed while the selection is
<a name="line1030"></a> * inside a blockquote, they hose the blockquote tag in weird and
<a name="line1031"></a> * unintuitive ways.
<a name="line1032"></a> * @const
<a name="line1033"></a> * @private
<a name="line1034"></a> */
<a name="line1035"></a>goog.editor.plugins.BasicTextFormatter.blockquoteHatingCommandsIE_ = {
<a name="line1036"></a>  &#39;insertOrderedList&#39; : 1,
<a name="line1037"></a>  &#39;insertUnorderedList&#39; : 1
<a name="line1038"></a>};
<a name="line1039"></a>
<a name="line1040"></a>
<a name="line1041"></a>/**
<a name="line1042"></a> * Makes sure that superscript is removed before applying subscript, and vice
<a name="line1043"></a> * versa. Fixes {@link http://buganizer/issue?id=1173491} .
<a name="line1044"></a> * @param {goog.editor.plugins.BasicTextFormatter.COMMAND} command The command
<a name="line1045"></a> *     being applied, either SUBSCRIPT or SUPERSCRIPT.
<a name="line1046"></a> * @private
<a name="line1047"></a> */
<a name="line1048"></a>goog.editor.plugins.BasicTextFormatter.
<a name="line1049"></a>    prototype.applySubscriptSuperscriptWorkarounds_ = function(command) {
<a name="line1050"></a>  if (!this.queryCommandValue(command)) {
<a name="line1051"></a>    // The current selection doesn&#39;t currently have the requested
<a name="line1052"></a>    // command, so we are applying it as opposed to removing it.
<a name="line1053"></a>    // (Note that queryCommandValue() will only return true if the
<a name="line1054"></a>    // command is applied to the whole selection, not just part of it.
<a name="line1055"></a>    // In this case it is fine because only if the whole selection has
<a name="line1056"></a>    // the command applied will we be removing it and thus skipping the
<a name="line1057"></a>    // removal of the opposite command.)
<a name="line1058"></a>    var oppositeCommand =
<a name="line1059"></a>        (command == goog.editor.plugins.BasicTextFormatter.COMMAND.SUBSCRIPT ?
<a name="line1060"></a>            goog.editor.plugins.BasicTextFormatter.COMMAND.SUPERSCRIPT :
<a name="line1061"></a>            goog.editor.plugins.BasicTextFormatter.COMMAND.SUBSCRIPT);
<a name="line1062"></a>    var oppositeExecCommand = goog.editor.plugins.BasicTextFormatter.
<a name="line1063"></a>        convertToRealExecCommand_(oppositeCommand);
<a name="line1064"></a>    // Executing the opposite command on a selection that already has it
<a name="line1065"></a>    // applied will cancel it out. But if the selection only has the
<a name="line1066"></a>    // opposite command applied to a part of it, the browser will
<a name="line1067"></a>    // normalize the selection to have the opposite command applied on
<a name="line1068"></a>    // the whole of it.
<a name="line1069"></a>    if (!this.queryCommandValue(oppositeCommand)) {
<a name="line1070"></a>      // The selection doesn&#39;t have the opposite command applied to the
<a name="line1071"></a>      // whole of it, so let&#39;s exec the opposite command to normalize
<a name="line1072"></a>      // the selection.
<a name="line1073"></a>      // Note: since we know both subscript and superscript commands
<a name="line1074"></a>      // will boil down to a simple call to the browser&#39;s execCommand(),
<a name="line1075"></a>      // for performance reasons we can do that directly instead of
<a name="line1076"></a>      // calling execCommandHelper_(). However this is a potential for
<a name="line1077"></a>      // bugs if the implementation of execCommandHelper_() is changed
<a name="line1078"></a>      // to do something more int eh case of subscript and superscript.
<a name="line1079"></a>      this.getDocument_().execCommand(oppositeExecCommand, false, null);
<a name="line1080"></a>    }
<a name="line1081"></a>    // Now that we know the whole selection has the opposite command
<a name="line1082"></a>    // applied, we exec it a second time to properly remove it.
<a name="line1083"></a>    this.getDocument_().execCommand(oppositeExecCommand, false, null);
<a name="line1084"></a>  }
<a name="line1085"></a>};
<a name="line1086"></a>
<a name="line1087"></a>
<a name="line1088"></a>/**
<a name="line1089"></a> * Removes inline font-size styles from elements fully contained in the
<a name="line1090"></a> * selection, so the font tags produced by execCommand work properly.
<a name="line1091"></a> * See {@bug 1286408}.
<a name="line1092"></a> * @private
<a name="line1093"></a> */
<a name="line1094"></a>goog.editor.plugins.BasicTextFormatter.prototype.removeFontSizeFromStyleAttrs_ =
<a name="line1095"></a>    function() {
<a name="line1096"></a>  // Expand the range so that we consider surrounding tags. E.g. if only the
<a name="line1097"></a>  // text node inside a span is selected, the browser could wrap a font tag
<a name="line1098"></a>  // around the span and leave the selection such that only the text node is
<a name="line1099"></a>  // found when looking inside the range, not the span.
<a name="line1100"></a>  var range = goog.editor.range.expand(this.fieldObject.getRange(),
<a name="line1101"></a>                                       this.fieldObject.getElement());
<a name="line1102"></a>  goog.iter.forEach(goog.iter.filter(range, function(tag, dummy, iter) {
<a name="line1103"></a>    return iter.isStartTag() &amp;&amp; range.containsNode(tag);
<a name="line1104"></a>  }), function(node) {
<a name="line1105"></a>    goog.style.setStyle(node, &#39;font-size&#39;, &#39;&#39;);
<a name="line1106"></a>    // Gecko doesn&#39;t remove empty style tags.
<a name="line1107"></a>    if (goog.userAgent.GECKO &amp;&amp;
<a name="line1108"></a>        node.style.length == 0 &amp;&amp; node.getAttribute(&#39;style&#39;) != null) {
<a name="line1109"></a>      node.removeAttribute(&#39;style&#39;);
<a name="line1110"></a>    }
<a name="line1111"></a>  });
<a name="line1112"></a>};
<a name="line1113"></a>
<a name="line1114"></a>
<a name="line1115"></a>/**
<a name="line1116"></a> * Apply pre-execCommand fixes for IE.
<a name="line1117"></a> * @param {string} command The command to execute.
<a name="line1118"></a> * @return {Array.&lt;Node&gt;} Array of nodes to be removed after the execCommand.
<a name="line1119"></a> *     Will never be longer than 2 elements.
<a name="line1120"></a> * @private
<a name="line1121"></a> */
<a name="line1122"></a>goog.editor.plugins.BasicTextFormatter.prototype.applyExecCommandIEFixes_ =
<a name="line1123"></a>    function(command) {
<a name="line1124"></a>  // IE has a crazy bug where executing list commands
<a name="line1125"></a>  // around blockquotes cause the blockquotes to get transformed
<a name="line1126"></a>  // into &quot;&lt;OL&gt;&lt;OL&gt;&quot; or &quot;&lt;UL&gt;&lt;UL&gt;&quot; tags.
<a name="line1127"></a>  var toRemove = [];
<a name="line1128"></a>  var endDiv = null;
<a name="line1129"></a>  var range = this.getRange_();
<a name="line1130"></a>  var dh = this.getFieldDomHelper();
<a name="line1131"></a>  if (command in
<a name="line1132"></a>      goog.editor.plugins.BasicTextFormatter.blockquoteHatingCommandsIE_) {
<a name="line1133"></a>    var parent = range &amp;&amp; range.getContainerElement();
<a name="line1134"></a>    if (parent) {
<a name="line1135"></a>      var blockquotes = goog.dom.getElementsByTagNameAndClass(
<a name="line1136"></a>          goog.dom.TagName.BLOCKQUOTE, null, parent);
<a name="line1137"></a>
<a name="line1138"></a>      // If a blockquote contains the selection, the fix is easy:
<a name="line1139"></a>      // add a dummy div to the blockquote that isn&#39;t in the current selection.
<a name="line1140"></a>      //
<a name="line1141"></a>      // if the selection contains a blockquote,
<a name="line1142"></a>      // there appears to be no easy way to protect it from getting mangled.
<a name="line1143"></a>      // For now, we&#39;re just going to punt on this and try to
<a name="line1144"></a>      // adjust the selection so that IE does something reasonable.
<a name="line1145"></a>      //
<a name="line1146"></a>      // TODO(nicksantos): Find a better fix for this.
<a name="line1147"></a>      var bq;
<a name="line1148"></a>      for (var i = 0; i &lt; blockquotes.length; i++) {
<a name="line1149"></a>        if (range.containsNode(blockquotes[i])) {
<a name="line1150"></a>          bq = blockquotes[i];
<a name="line1151"></a>          break;
<a name="line1152"></a>        }
<a name="line1153"></a>      }
<a name="line1154"></a>
<a name="line1155"></a>      var bqThatNeedsDummyDiv =
<a name="line1156"></a>          bq || goog.dom.getAncestorByTagNameAndClass(parent, &#39;BLOCKQUOTE&#39;);
<a name="line1157"></a>      if (bqThatNeedsDummyDiv) {
<a name="line1158"></a>        endDiv = dh.createDom(&#39;div&#39;, {style: &#39;height:0&#39;});
<a name="line1159"></a>        goog.dom.appendChild(bqThatNeedsDummyDiv, endDiv);
<a name="line1160"></a>        toRemove.push(endDiv);
<a name="line1161"></a>
<a name="line1162"></a>        if (bq) {
<a name="line1163"></a>          range = goog.dom.Range.createFromNodes(bq, 0, endDiv, 0);
<a name="line1164"></a>        } else if (range.containsNode(endDiv)) {
<a name="line1165"></a>          // the selection might be the entire blockquote, and
<a name="line1166"></a>          // it&#39;s important that endDiv not be in the selection.
<a name="line1167"></a>          range = goog.dom.Range.createFromNodes(
<a name="line1168"></a>              range.getStartNode(), range.getStartOffset(),
<a name="line1169"></a>              endDiv, 0);
<a name="line1170"></a>        }
<a name="line1171"></a>        range.select();
<a name="line1172"></a>      }
<a name="line1173"></a>    }
<a name="line1174"></a>  }
<a name="line1175"></a>
<a name="line1176"></a>  // IE has a crazy bug where certain block execCommands cause it to mess with
<a name="line1177"></a>  // the DOM nodes above the contentEditable element if the selection contains
<a name="line1178"></a>  // or partially contains the last block element in the contentEditable
<a name="line1179"></a>  // element.
<a name="line1180"></a>  // Known commands: Indent, outdent, insertorderedlist, insertunorderedlist,
<a name="line1181"></a>  // Justify (all of them)
<a name="line1182"></a>
<a name="line1183"></a>  // Both of the above are &quot;solved&quot; by appending a dummy div to the field
<a name="line1184"></a>  // before the execCommand and removing it after, but we don&#39;t need to do this
<a name="line1185"></a>  // if we&#39;ve alread added a dummy div somewhere else.
<a name="line1186"></a>  var fieldObject = this.fieldObject;
<a name="line1187"></a>  if (!fieldObject.usesIframe() &amp;&amp; !endDiv) {
<a name="line1188"></a>    if (command in
<a name="line1189"></a>        goog.editor.plugins.BasicTextFormatter.brokenExecCommandsIE_) {
<a name="line1190"></a>      var field = fieldObject.getElement();
<a name="line1191"></a>
<a name="line1192"></a>      // If the field is totally empty, or if the field contains only text nodes
<a name="line1193"></a>      // and the cursor is at the end of the field, then IE stills walks outside
<a name="line1194"></a>      // the contentEditable region and destroys things AND justify will not
<a name="line1195"></a>      // work. This is &quot;solved&quot; by adding a text node into the end of the
<a name="line1196"></a>      // field and moving the cursor before it.
<a name="line1197"></a>      if (range &amp;&amp; range.isCollapsed() &amp;&amp;
<a name="line1198"></a>          !goog.dom.getFirstElementChild(field)) {
<a name="line1199"></a>        // The problem only occurs if the selection is at the end of the field.
<a name="line1200"></a>        var selection = range.getTextRange(0).getBrowserRangeObject();
<a name="line1201"></a>        var testRange = selection.duplicate();
<a name="line1202"></a>        testRange.moveToElementText(field);
<a name="line1203"></a>        testRange.collapse(false);
<a name="line1204"></a>
<a name="line1205"></a>        if (testRange.isEqual(selection)) {
<a name="line1206"></a>          // For reasons I really don&#39;t understand, if you use a breaking space
<a name="line1207"></a>          // here, either &quot; &quot; or String.fromCharCode(32), this textNode becomes
<a name="line1208"></a>          // corrupted, only after you hit ENTER to split it.  It exists in the
<a name="line1209"></a>          // dom in that its parent has it as childNode and the parent&#39;s
<a name="line1210"></a>          // innerText is correct, but the node itself throws invalid argument
<a name="line1211"></a>          // errors when you try to access its data, parentNode, nextSibling,
<a name="line1212"></a>          // previousSibling or most other properties.  WTF.
<a name="line1213"></a>          var nbsp = dh.createTextNode(goog.string.Unicode.NBSP);
<a name="line1214"></a>          field.appendChild(nbsp);
<a name="line1215"></a>          selection.move(&#39;character&#39;, 1);
<a name="line1216"></a>          selection.move(&#39;character&#39;, -1);
<a name="line1217"></a>          selection.select();
<a name="line1218"></a>          toRemove.push(nbsp);
<a name="line1219"></a>        }
<a name="line1220"></a>      }
<a name="line1221"></a>
<a name="line1222"></a>      endDiv = dh.createDom(&#39;div&#39;, {style: &#39;height:0&#39;});
<a name="line1223"></a>      goog.dom.appendChild(field, endDiv);
<a name="line1224"></a>      toRemove.push(endDiv);
<a name="line1225"></a>    }
<a name="line1226"></a>  }
<a name="line1227"></a>
<a name="line1228"></a>  return toRemove;
<a name="line1229"></a>};
<a name="line1230"></a>
<a name="line1231"></a>
<a name="line1232"></a>/**
<a name="line1233"></a> * Fix a ridiculous Safari bug: the first letters of new headings
<a name="line1234"></a> * somehow retain their original font size and weight if multiple lines are
<a name="line1235"></a> * selected during the execCommand that turns them into headings.
<a name="line1236"></a> * The solution is to strip these styles which are normally stripped when
<a name="line1237"></a> * making things headings anyway.
<a name="line1238"></a> * @private
<a name="line1239"></a> */
<a name="line1240"></a>goog.editor.plugins.BasicTextFormatter.prototype.cleanUpSafariHeadings_ =
<a name="line1241"></a>    function() {
<a name="line1242"></a>  goog.iter.forEach(this.getRange_(), function(node) {
<a name="line1243"></a>    if (node.className == &#39;Apple-style-span&#39;) {
<a name="line1244"></a>      // These shouldn&#39;t persist after creating headings via
<a name="line1245"></a>      // a FormatBlock execCommand.
<a name="line1246"></a>      node.style.fontSize = &#39;&#39;;
<a name="line1247"></a>      node.style.fontWeight = &#39;&#39;;
<a name="line1248"></a>    }
<a name="line1249"></a>  });
<a name="line1250"></a>};
<a name="line1251"></a>
<a name="line1252"></a>
<a name="line1253"></a>/**
<a name="line1254"></a> * Prevent Safari from making each list item be &quot;1&quot; when converting from
<a name="line1255"></a> * unordered to ordered lists.
<a name="line1256"></a> * (see https://bugs.webkit.org/show_bug.cgi?id=19539 )
<a name="line1257"></a> * @private
<a name="line1258"></a> */
<a name="line1259"></a>goog.editor.plugins.BasicTextFormatter.prototype.fixSafariLists_ = function() {
<a name="line1260"></a>  var previousList = false;
<a name="line1261"></a>  goog.iter.forEach(this.getRange_(), function(node) {
<a name="line1262"></a>    var tagName = node.tagName;
<a name="line1263"></a>    if (tagName == goog.dom.TagName.UL || tagName == goog.dom.TagName.OL) {
<a name="line1264"></a>      // Don&#39;t disturb lists outside of the selection. If this is the first &lt;ul&gt;
<a name="line1265"></a>      // or &lt;ol&gt; in the range, we don&#39;t really want to merge the previous list
<a name="line1266"></a>      // into it, since that list isn&#39;t in the range.
<a name="line1267"></a>      if (!previousList) {
<a name="line1268"></a>        previousList = true;
<a name="line1269"></a>        return;
<a name="line1270"></a>      }
<a name="line1271"></a>      // The lists must be siblings to be merged; otherwise, indented sublists
<a name="line1272"></a>      // could be broken.
<a name="line1273"></a>      var previousElementSibling = goog.dom.getPreviousElementSibling(node);
<a name="line1274"></a>      if (!previousElementSibling) {
<a name="line1275"></a>        return;
<a name="line1276"></a>      }
<a name="line1277"></a>      // Make sure there isn&#39;t text between the two lists before they are merged
<a name="line1278"></a>      var range = node.ownerDocument.createRange();
<a name="line1279"></a>      range.setStartAfter(previousElementSibling);
<a name="line1280"></a>      range.setEndBefore(node);
<a name="line1281"></a>      if (!goog.string.isEmpty(range.toString())) {
<a name="line1282"></a>        return;
<a name="line1283"></a>      }
<a name="line1284"></a>      // Make sure both are lists of the same type (ordered or unordered)
<a name="line1285"></a>      if (previousElementSibling.nodeName == node.nodeName) {
<a name="line1286"></a>        // We must merge the previous list into this one. Moving around
<a name="line1287"></a>        // the current node will break the iterator, so we can&#39;t merge
<a name="line1288"></a>        // this list into the previous one.
<a name="line1289"></a>        while (previousElementSibling.lastChild) {
<a name="line1290"></a>          node.insertBefore(previousElementSibling.lastChild, node.firstChild);
<a name="line1291"></a>        }
<a name="line1292"></a>        previousElementSibling.parentNode.removeChild(previousElementSibling);
<a name="line1293"></a>      }
<a name="line1294"></a>    }
<a name="line1295"></a>  });
<a name="line1296"></a>};
<a name="line1297"></a>
<a name="line1298"></a>
<a name="line1299"></a>/**
<a name="line1300"></a> * Sane &quot;type&quot; attribute values for OL elements
<a name="line1301"></a> * @private
<a name="line1302"></a> */
<a name="line1303"></a>goog.editor.plugins.BasicTextFormatter.orderedListTypes_ = {
<a name="line1304"></a>  &#39;1&#39; : 1,
<a name="line1305"></a>  &#39;a&#39; : 1,
<a name="line1306"></a>  &#39;A&#39; : 1,
<a name="line1307"></a>  &#39;i&#39; : 1,
<a name="line1308"></a>  &#39;I&#39; : 1
<a name="line1309"></a>};
<a name="line1310"></a>
<a name="line1311"></a>
<a name="line1312"></a>/**
<a name="line1313"></a> * Sane &quot;type&quot; attribute values for UL elements
<a name="line1314"></a> * @private
<a name="line1315"></a> */
<a name="line1316"></a>goog.editor.plugins.BasicTextFormatter.unorderedListTypes_ = {
<a name="line1317"></a>  &#39;disc&#39; : 1,
<a name="line1318"></a>  &#39;circle&#39; : 1,
<a name="line1319"></a>  &#39;square&#39; : 1
<a name="line1320"></a>};
<a name="line1321"></a>
<a name="line1322"></a>
<a name="line1323"></a>/**
<a name="line1324"></a> * Changing an OL to a UL (or the other way around) will fail if the list
<a name="line1325"></a> * has a type attribute (such as &quot;UL type=disc&quot; becoming &quot;OL type=disc&quot;, which
<a name="line1326"></a> * is visually identical). Most browsers will remove the type attribute
<a name="line1327"></a> * automatically, but IE doesn&#39;t. This does it manually.
<a name="line1328"></a> * @private
<a name="line1329"></a> */
<a name="line1330"></a>goog.editor.plugins.BasicTextFormatter.prototype.fixIELists_ = function() {
<a name="line1331"></a>  // Find the lowest-level &lt;ul&gt; or &lt;ol&gt; that contains the entire range.
<a name="line1332"></a>  var range = this.getRange_();
<a name="line1333"></a>  var container = range &amp;&amp; range.getContainer();
<a name="line1334"></a>  while (container &amp;&amp;
<a name="line1335"></a>         container.tagName != goog.dom.TagName.UL &amp;&amp;
<a name="line1336"></a>         container.tagName != goog.dom.TagName.OL) {
<a name="line1337"></a>    container = container.parentNode;
<a name="line1338"></a>  }
<a name="line1339"></a>  if (container) {
<a name="line1340"></a>    // We want the parent node of the list so that we can grab it using
<a name="line1341"></a>    // getElementsByTagName
<a name="line1342"></a>    container = container.parentNode;
<a name="line1343"></a>  }
<a name="line1344"></a>  if (!container) return;
<a name="line1345"></a>  var lists = goog.array.toArray(
<a name="line1346"></a>      container.getElementsByTagName(goog.dom.TagName.UL));
<a name="line1347"></a>  goog.array.extend(lists, goog.array.toArray(
<a name="line1348"></a>      container.getElementsByTagName(goog.dom.TagName.OL)));
<a name="line1349"></a>  // Fix the lists
<a name="line1350"></a>  goog.array.forEach(lists, function(node) {
<a name="line1351"></a>    var type = node.type;
<a name="line1352"></a>    if (type) {
<a name="line1353"></a>      var saneTypes =
<a name="line1354"></a>          (node.tagName == goog.dom.TagName.UL ?
<a name="line1355"></a>              goog.editor.plugins.BasicTextFormatter.unorderedListTypes_ :
<a name="line1356"></a>              goog.editor.plugins.BasicTextFormatter.orderedListTypes_);
<a name="line1357"></a>      if (!saneTypes[type]) {
<a name="line1358"></a>        node.type = &#39;&#39;;
<a name="line1359"></a>      }
<a name="line1360"></a>    }
<a name="line1361"></a>  });
<a name="line1362"></a>};
<a name="line1363"></a>
<a name="line1364"></a>
<a name="line1365"></a>/**
<a name="line1366"></a> * In WebKit, the following commands will modify the node with
<a name="line1367"></a> * contentEditable=true if there are no block-level elements.
<a name="line1368"></a> * @private
<a name="line1369"></a> */
<a name="line1370"></a>goog.editor.plugins.BasicTextFormatter.brokenExecCommandsSafari_ = {
<a name="line1371"></a>  &#39;justifyCenter&#39; : 1,
<a name="line1372"></a>  &#39;justifyFull&#39; : 1,
<a name="line1373"></a>  &#39;justifyRight&#39;: 1,
<a name="line1374"></a>  &#39;justifyLeft&#39;: 1,
<a name="line1375"></a>  &#39;formatBlock&#39; : 1
<a name="line1376"></a>};
<a name="line1377"></a>
<a name="line1378"></a>
<a name="line1379"></a>/**
<a name="line1380"></a> * In WebKit, the following commands can hang the browser if the selection
<a name="line1381"></a> * touches the beginning of the field.
<a name="line1382"></a> * https://bugs.webkit.org/show_bug.cgi?id=19735
<a name="line1383"></a> * @private
<a name="line1384"></a> */
<a name="line1385"></a>goog.editor.plugins.BasicTextFormatter.hangingExecCommandWebkit_ = {
<a name="line1386"></a>  &#39;insertOrderedList&#39;: 1,
<a name="line1387"></a>  &#39;insertUnorderedList&#39;: 1
<a name="line1388"></a>};
<a name="line1389"></a>
<a name="line1390"></a>
<a name="line1391"></a>/**
<a name="line1392"></a> * Apply pre-execCommand fixes for Safari.
<a name="line1393"></a> * @param {string} command The command to execute.
<a name="line1394"></a> * @return {Element|undefined} The div added to the field.
<a name="line1395"></a> * @private
<a name="line1396"></a> */
<a name="line1397"></a>goog.editor.plugins.BasicTextFormatter.prototype.applyExecCommandSafariFixes_ =
<a name="line1398"></a>    function(command) {
<a name="line1399"></a>  // See the comment on brokenExecCommandsSafari_
<a name="line1400"></a>  var div;
<a name="line1401"></a>  if (goog.editor.plugins.BasicTextFormatter.
<a name="line1402"></a>      brokenExecCommandsSafari_[command]) {
<a name="line1403"></a>    // Add a new div at the end of the field.
<a name="line1404"></a>    // Safari knows that it would be wrong to apply text-align to the
<a name="line1405"></a>    // contentEditable element if there are non-empty block nodes in the field,
<a name="line1406"></a>    // because then it would align them too. So in this case, it will
<a name="line1407"></a>    // enclose the current selection in a block node.
<a name="line1408"></a>    div = this.getFieldDomHelper().createDom(
<a name="line1409"></a>        &#39;div&#39;, {&#39;style&#39;: &#39;height: 0&#39;}, &#39;x&#39;);
<a name="line1410"></a>    goog.dom.appendChild(this.fieldObject.getElement(), div);
<a name="line1411"></a>  }
<a name="line1412"></a>
<a name="line1413"></a>  if (goog.editor.plugins.BasicTextFormatter.
<a name="line1414"></a>      hangingExecCommandWebkit_[command]) {
<a name="line1415"></a>    // Add a new div at the beginning of the field.
<a name="line1416"></a>    var field = this.fieldObject.getElement();
<a name="line1417"></a>    div = this.getFieldDomHelper().createDom(
<a name="line1418"></a>        &#39;div&#39;, {&#39;style&#39;: &#39;height: 0&#39;}, &#39;x&#39;);
<a name="line1419"></a>    field.insertBefore(div, field.firstChild);
<a name="line1420"></a>  }
<a name="line1421"></a>
<a name="line1422"></a>  return div;
<a name="line1423"></a>};
<a name="line1424"></a>
<a name="line1425"></a>
<a name="line1426"></a>/**
<a name="line1427"></a> * Apply pre-execCommand fixes for Gecko.
<a name="line1428"></a> * @param {string} command The command to execute.
<a name="line1429"></a> * @private
<a name="line1430"></a> */
<a name="line1431"></a>goog.editor.plugins.BasicTextFormatter.prototype.applyExecCommandGeckoFixes_ =
<a name="line1432"></a>    function(command) {
<a name="line1433"></a>  if (goog.userAgent.isVersion(&#39;1.9&#39;) &amp;&amp;
<a name="line1434"></a>      command.toLowerCase() == &#39;formatblock&#39;) {
<a name="line1435"></a>    // Firefox 3 and above throw a JS error for formatblock if the range is
<a name="line1436"></a>    // a child of the body node. Changing the selection to the BR fixes the
<a name="line1437"></a>    // problem.
<a name="line1438"></a>    // See https://bugzilla.mozilla.org/show_bug.cgi?id=481696
<a name="line1439"></a>    var range = this.getRange_();
<a name="line1440"></a>    var startNode = range.getStartNode();
<a name="line1441"></a>    if (range.isCollapsed() &amp;&amp; startNode &amp;&amp;
<a name="line1442"></a>        startNode.tagName == goog.dom.TagName.BODY) {
<a name="line1443"></a>      var startOffset = range.getStartOffset();
<a name="line1444"></a>      var childNode = startNode.childNodes[startOffset];
<a name="line1445"></a>      if (childNode &amp;&amp; childNode.tagName == goog.dom.TagName.BR) {
<a name="line1446"></a>        // Change the range using getBrowserRange() because goog.dom.TextRange
<a name="line1447"></a>        // will avoid setting &lt;br&gt;s directly.
<a name="line1448"></a>        // @see goog.dom.TextRange#createFromNodes
<a name="line1449"></a>        var browserRange = range.getBrowserRangeObject();
<a name="line1450"></a>        browserRange.setStart(childNode, 0);
<a name="line1451"></a>        browserRange.setEnd(childNode, 0);
<a name="line1452"></a>      }
<a name="line1453"></a>    }
<a name="line1454"></a>  }
<a name="line1455"></a>};
<a name="line1456"></a>
<a name="line1457"></a>
<a name="line1458"></a>/**
<a name="line1459"></a> * Workaround for Opera bug CORE-23903. Opera sometimes fails to invalidate
<a name="line1460"></a> * serialized CSS or innerHTML for the DOM after certain execCommands when
<a name="line1461"></a> * styleWithCSS is on. Toggling an inline style on the elements fixes it.
<a name="line1462"></a> * @private
<a name="line1463"></a> */
<a name="line1464"></a>goog.editor.plugins.BasicTextFormatter.prototype.invalidateInlineCss_ =
<a name="line1465"></a>    function() {
<a name="line1466"></a>  var ancestors = [];
<a name="line1467"></a>  var ancestor = this.fieldObject.getRange().getContainerElement();
<a name="line1468"></a>  do {
<a name="line1469"></a>    ancestors.push(ancestor);
<a name="line1470"></a>  } while (ancestor = ancestor.parentNode);
<a name="line1471"></a>  var nodesInSelection = goog.iter.chain(
<a name="line1472"></a>      goog.iter.toIterator(this.fieldObject.getRange()),
<a name="line1473"></a>      goog.iter.toIterator(ancestors));
<a name="line1474"></a>  var containersInSelection =
<a name="line1475"></a>      goog.iter.filter(nodesInSelection, goog.editor.style.isContainer);
<a name="line1476"></a>  goog.iter.forEach(containersInSelection, function(element) {
<a name="line1477"></a>    var oldOutline = element.style.outline;
<a name="line1478"></a>    element.style.outline = &#39;0px solid red&#39;;
<a name="line1479"></a>    element.style.outline = oldOutline;
<a name="line1480"></a>  });
<a name="line1481"></a>};
<a name="line1482"></a>
<a name="line1483"></a>
<a name="line1484"></a>/**
<a name="line1485"></a> * Work around a Gecko bug that causes inserted lists to forget the current
<a name="line1486"></a> * font. This affects WebKit in the same way and Opera in a slightly different
<a name="line1487"></a> * way, but this workaround only works in Gecko.
<a name="line1488"></a> * WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=19653
<a name="line1489"></a> * Mozilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=439966
<a name="line1490"></a> * Opera bug: https://bugs.opera.com/show_bug.cgi?id=340392
<a name="line1491"></a> * TODO: work around this issue in WebKit and Opera as well.
<a name="line1492"></a> * @return {boolean} Whether the workaround was applied.
<a name="line1493"></a> * @private
<a name="line1494"></a> */
<a name="line1495"></a>goog.editor.plugins.BasicTextFormatter.prototype.beforeInsertListGecko_ =
<a name="line1496"></a>    function() {
<a name="line1497"></a>  var tag = this.fieldObject.queryCommandValue(goog.editor.Command.DEFAULT_TAG);
<a name="line1498"></a>  if (tag == goog.dom.TagName.P || tag == goog.dom.TagName.DIV) {
<a name="line1499"></a>    return false;
<a name="line1500"></a>  }
<a name="line1501"></a>
<a name="line1502"></a>  // Prevent Firefox from forgetting current formatting
<a name="line1503"></a>  // when creating a list.
<a name="line1504"></a>  // The bug happens with a collapsed selection, but it won&#39;t
<a name="line1505"></a>  // happen when text with the desired formatting is selected.
<a name="line1506"></a>  // So, we insert some dummy text, insert the list,
<a name="line1507"></a>  // then remove the dummy text (while preserving its formatting).
<a name="line1508"></a>  // (This formatting bug also affects WebKit, but this fix
<a name="line1509"></a>  // only seems to work in Firefox)
<a name="line1510"></a>  var range = this.getRange_();
<a name="line1511"></a>  if (range.isCollapsed() &amp;&amp;
<a name="line1512"></a>      (range.getContainer().nodeType != goog.dom.NodeType.TEXT)) {
<a name="line1513"></a>    var tempTextNode = this.getFieldDomHelper().
<a name="line1514"></a>        createTextNode(goog.string.Unicode.NBSP);
<a name="line1515"></a>    range.insertNode(tempTextNode, false);
<a name="line1516"></a>    goog.dom.Range.createFromNodeContents(tempTextNode).select();
<a name="line1517"></a>    return true;
<a name="line1518"></a>  }
<a name="line1519"></a>  return false;
<a name="line1520"></a>};
<a name="line1521"></a>
<a name="line1522"></a>
<a name="line1523"></a>// Helpers for queryCommandState
<a name="line1524"></a>
<a name="line1525"></a>
<a name="line1526"></a>/**
<a name="line1527"></a> * Get the toolbar state for the block-level elements in the given range.
<a name="line1528"></a> * @param {goog.dom.AbstractRange} range The range to get toolbar state for.
<a name="line1529"></a> * @return {string?} The selection block state.
<a name="line1530"></a> * @private
<a name="line1531"></a> */
<a name="line1532"></a>goog.editor.plugins.BasicTextFormatter.getSelectionBlockState_ =
<a name="line1533"></a>    function(range) {
<a name="line1534"></a>  var tagName = null;
<a name="line1535"></a>  goog.iter.forEach(range, function(node, ignore, it) {
<a name="line1536"></a>    if (!it.isEndTag()) {
<a name="line1537"></a>      // Iterate over all containers in the range, checking if they all have the
<a name="line1538"></a>      // same tagName.
<a name="line1539"></a>      var container = goog.editor.style.getContainer(node);
<a name="line1540"></a>      var thisTagName = container.tagName;
<a name="line1541"></a>      tagName = tagName || thisTagName;
<a name="line1542"></a>
<a name="line1543"></a>      if (tagName != thisTagName) {
<a name="line1544"></a>        // If we find a container tag that doesn&#39;t match, exit right away.
<a name="line1545"></a>        tagName = null;
<a name="line1546"></a>        throw goog.iter.StopIteration;
<a name="line1547"></a>      }
<a name="line1548"></a>
<a name="line1549"></a>      // Skip the tag.
<a name="line1550"></a>      it.skipTag();
<a name="line1551"></a>    }
<a name="line1552"></a>  });
<a name="line1553"></a>
<a name="line1554"></a>  return tagName;
<a name="line1555"></a>};
<a name="line1556"></a>
<a name="line1557"></a>
<a name="line1558"></a>/**
<a name="line1559"></a> * Hash of suppoted justifications.
<a name="line1560"></a> * @type {Object}
<a name="line1561"></a> * @private
<a name="line1562"></a> */
<a name="line1563"></a>goog.editor.plugins.BasicTextFormatter.SUPPORTED_JUSTIFICATIONS_ = {
<a name="line1564"></a>  &#39;center&#39;: 1,
<a name="line1565"></a>  &#39;justify&#39;: 1,
<a name="line1566"></a>  &#39;right&#39;: 1,
<a name="line1567"></a>  &#39;left&#39;: 1
<a name="line1568"></a>};
<a name="line1569"></a>
<a name="line1570"></a>
<a name="line1571"></a>/**
<a name="line1572"></a> * Returns true if the current justification matches the justification
<a name="line1573"></a> * command for the entire selection.
<a name="line1574"></a> * @param {string} command The justification command to check for.
<a name="line1575"></a> * @return {boolean} Whether the current justification matches the justification
<a name="line1576"></a> *     command for the entire selection.
<a name="line1577"></a> * @private
<a name="line1578"></a> */
<a name="line1579"></a>goog.editor.plugins.BasicTextFormatter.prototype.isJustification_ =
<a name="line1580"></a>    function(command) {
<a name="line1581"></a>  var alignment = command.replace(&#39;+justify&#39;, &#39;&#39;).toLowerCase();
<a name="line1582"></a>  if (alignment == &#39;full&#39;) {
<a name="line1583"></a>    alignment = &#39;justify&#39;;
<a name="line1584"></a>  }
<a name="line1585"></a>  var bidiPlugin = this.fieldObject.getPluginByClassId(&#39;Bidi&#39;);
<a name="line1586"></a>  if (bidiPlugin) {
<a name="line1587"></a>    // BiDi aware version
<a name="line1588"></a>
<a name="line1589"></a>    // TODO: Since getComputedStyle is not used here, this version may be even
<a name="line1590"></a>    // faster. If profiling confirms that it would be good to use this approach
<a name="line1591"></a>    // in both cases. Otherwise the bidi part should be moved into an
<a name="line1592"></a>    // execCommand so this bidi plugin dependence isn&#39;t needed here.
<a name="line1593"></a>    /** @type {Function} */
<a name="line1594"></a>    bidiPlugin.getSelectionAlignment;
<a name="line1595"></a>    return alignment == bidiPlugin.getSelectionAlignment();
<a name="line1596"></a>  } else {
<a name="line1597"></a>    // BiDi unaware version
<a name="line1598"></a>    var range = this.getRange_();
<a name="line1599"></a>    if (!range) {
<a name="line1600"></a>      // When nothing is in the selection then no justification
<a name="line1601"></a>      // command matches.
<a name="line1602"></a>      return false;
<a name="line1603"></a>    }
<a name="line1604"></a>
<a name="line1605"></a>    var parent = range.getContainerElement();
<a name="line1606"></a>    var nodes =
<a name="line1607"></a>        goog.array.filter(
<a name="line1608"></a>            parent.childNodes,
<a name="line1609"></a>            function(node) {
<a name="line1610"></a>              return goog.editor.node.isImportant(node) &amp;&amp;
<a name="line1611"></a>                  range.containsNode(node, true);
<a name="line1612"></a>            });
<a name="line1613"></a>    nodes = nodes.length ? nodes : [parent];
<a name="line1614"></a>
<a name="line1615"></a>    for (var i = 0; i &lt; nodes.length; i++) {
<a name="line1616"></a>      var current = nodes[i];
<a name="line1617"></a>
<a name="line1618"></a>      // If any node in the selection is not aligned the way we are checking,
<a name="line1619"></a>      // then the justification command does not match.
<a name="line1620"></a>      var container = goog.editor.style.getContainer(
<a name="line1621"></a>          /** @type {Node} */ (current));
<a name="line1622"></a>      if (alignment !=
<a name="line1623"></a>          goog.editor.plugins.BasicTextFormatter.getNodeJustification_(
<a name="line1624"></a>              container)) {
<a name="line1625"></a>        return false;
<a name="line1626"></a>      }
<a name="line1627"></a>    }
<a name="line1628"></a>
<a name="line1629"></a>    // If all nodes in the selection are aligned the way we are checking,
<a name="line1630"></a>    // the justification command does match.
<a name="line1631"></a>    return true;
<a name="line1632"></a>  }
<a name="line1633"></a>};
<a name="line1634"></a>
<a name="line1635"></a>
<a name="line1636"></a>/**
<a name="line1637"></a> * Determines the justification for a given block-level element.
<a name="line1638"></a> * @param {Element} element The node to get justification for.
<a name="line1639"></a> * @return {string} The justification for a given block-level node.
<a name="line1640"></a> * @private
<a name="line1641"></a> */
<a name="line1642"></a>goog.editor.plugins.BasicTextFormatter.getNodeJustification_ =
<a name="line1643"></a>    function(element) {
<a name="line1644"></a>  var value = goog.style.getComputedTextAlign(element);
<a name="line1645"></a>  // Strip preceding -moz- or -webkit- (@bug 2472589).
<a name="line1646"></a>  value = value.replace(/^-(moz|webkit)-/, &#39;&#39;);
<a name="line1647"></a>
<a name="line1648"></a>  // If there is no alignment, try the inline property,
<a name="line1649"></a>  // otherwise assume left aligned.
<a name="line1650"></a>  // TODO: for rtl languages we probably need to assume right.
<a name="line1651"></a>  if (!goog.editor.plugins.BasicTextFormatter.
<a name="line1652"></a>      SUPPORTED_JUSTIFICATIONS_[value]) {
<a name="line1653"></a>    value = element.align || &#39;left&#39;;
<a name="line1654"></a>  }
<a name="line1655"></a>  return /** @type {string} */ (value);
<a name="line1656"></a>};
<a name="line1657"></a>
<a name="line1658"></a>
<a name="line1659"></a>/**
<a name="line1660"></a> * Returns true if a selection contained in the node should set the appropriate
<a name="line1661"></a> * toolbar state for the given nodeName, e.g. if the node is contained in a
<a name="line1662"></a> * strong element and nodeName is &quot;strong&quot;, then it will return true.
<a name="line1663"></a> * @param {string} nodeName The type of node to check for.
<a name="line1664"></a> * @return {boolean} Whether the user&#39;s selection is in the given state.
<a name="line1665"></a> * @private
<a name="line1666"></a> */
<a name="line1667"></a>goog.editor.plugins.BasicTextFormatter.prototype.isNodeInState_ =
<a name="line1668"></a>    function(nodeName) {
<a name="line1669"></a>  var range = this.getRange_();
<a name="line1670"></a>  var node = range &amp;&amp; range.getContainerElement();
<a name="line1671"></a>  var ancestor = goog.dom.getAncestorByTagNameAndClass(node, nodeName);
<a name="line1672"></a>  return !!ancestor &amp;&amp; goog.editor.node.isEditable(ancestor);
<a name="line1673"></a>};
<a name="line1674"></a>
<a name="line1675"></a>
<a name="line1676"></a>/**
<a name="line1677"></a> * Wrapper for browser&#39;s queryCommandState.
<a name="line1678"></a> * @param {Document|TextRange|Range} queryObject The object to query.
<a name="line1679"></a> * @param {string} command The command to check.
<a name="line1680"></a> * @param {boolean=} opt_styleWithCss Set to true to enable styleWithCSS before
<a name="line1681"></a> *     performing the queryCommandState.
<a name="line1682"></a> * @return {boolean} The command state.
<a name="line1683"></a> * @private
<a name="line1684"></a> */
<a name="line1685"></a>goog.editor.plugins.BasicTextFormatter.prototype.queryCommandStateInternal_ =
<a name="line1686"></a>    function(queryObject, command, opt_styleWithCss) {
<a name="line1687"></a>  return /** @type {boolean} */ (this.queryCommandHelper_(true, queryObject,
<a name="line1688"></a>      command, opt_styleWithCss));
<a name="line1689"></a>};
<a name="line1690"></a>
<a name="line1691"></a>
<a name="line1692"></a>/**
<a name="line1693"></a> * Wrapper for browser&#39;s queryCommandValue.
<a name="line1694"></a> * @param {Document|TextRange|Range} queryObject The object to query.
<a name="line1695"></a> * @param {string} command The command to check.
<a name="line1696"></a> * @param {boolean=} opt_styleWithCss Set to true to enable styleWithCSS before
<a name="line1697"></a> *     performing the queryCommandValue.
<a name="line1698"></a> * @return {string|boolean|null} The command value.
<a name="line1699"></a> * @private
<a name="line1700"></a> */
<a name="line1701"></a>goog.editor.plugins.BasicTextFormatter.prototype.queryCommandValueInternal_ =
<a name="line1702"></a>    function(queryObject, command, opt_styleWithCss) {
<a name="line1703"></a>  return this.queryCommandHelper_(false, queryObject,
<a name="line1704"></a>      command, opt_styleWithCss);
<a name="line1705"></a>};
<a name="line1706"></a>
<a name="line1707"></a>
<a name="line1708"></a>/**
<a name="line1709"></a> * Helper function to perform queryCommand(Value|State).
<a name="line1710"></a> * @param {boolean} isGetQueryCommandState True to use queryCommandState, false
<a name="line1711"></a> *     to use queryCommandValue.
<a name="line1712"></a> * @param {Document|TextRange|Range} queryObject The object to query.
<a name="line1713"></a> * @param {string} command The command to check.
<a name="line1714"></a> * @param {boolean=} opt_styleWithCss Set to true to enable styleWithCSS before
<a name="line1715"></a> *     performing the queryCommand(Value|State).
<a name="line1716"></a> * @return {string|boolean|null} The command value.
<a name="line1717"></a> * @private
<a name="line1718"></a> */
<a name="line1719"></a>goog.editor.plugins.BasicTextFormatter.prototype.queryCommandHelper_ = function(
<a name="line1720"></a>    isGetQueryCommandState, queryObject, command, opt_styleWithCss) {
<a name="line1721"></a>  command =
<a name="line1722"></a>      goog.editor.plugins.BasicTextFormatter.convertToRealExecCommand_(
<a name="line1723"></a>          command);
<a name="line1724"></a>  if (opt_styleWithCss) {
<a name="line1725"></a>    var doc = this.getDocument_();
<a name="line1726"></a>    // Don&#39;t use this.execCommandHelper_ here, as it is more heavyweight
<a name="line1727"></a>    // and inserts a dummy div to protect against comamnds that could step
<a name="line1728"></a>    // outside the editable region, which would cause change event on
<a name="line1729"></a>    // every toolbar update.
<a name="line1730"></a>    doc.execCommand(&#39;styleWithCSS&#39;, false, true);
<a name="line1731"></a>  }
<a name="line1732"></a>  var ret = isGetQueryCommandState ? queryObject.queryCommandState(command) :
<a name="line1733"></a>      queryObject.queryCommandValue(command);
<a name="line1734"></a>  if (opt_styleWithCss) {
<a name="line1735"></a>    doc.execCommand(&#39;styleWithCSS&#39;, false, false);
<a name="line1736"></a>  }
<a name="line1737"></a>  return ret;
<a name="line1738"></a>};
</pre>


</body>
</html>
